# PIDå˜é‡åœæ­¢æ›´æ–°åŸå› åˆ†æ

**æ—¥æœŸï¼š** 2025-10-10  
**é—®é¢˜ï¼š** äº‘å°åœ¨åŠ¨ï¼Œä½† `angle_PID.Ref` å’Œ `angle_PID.Output` å˜é‡åœä¸‹æ¥

---

## ğŸ¯ å˜é‡å«ä¹‰è¯¦è§£

### 1ï¸âƒ£ `angle_PID.Ref` ï¼ˆè§’åº¦ç¯å‚è€ƒå€¼ï¼‰

```c
yaw_motor->motor_controller.angle_PID.Ref
```

**å«ä¹‰ï¼š** ä½ å¸Œæœ›äº‘å°è½¬åˆ°çš„ç›®æ ‡è§’åº¦

**æ›´æ–°ä½ç½®ï¼š** åœ¨ `PIDCalculate()` å‡½æ•°å†…éƒ¨æ›´æ–°
```c
// modules/algorithm/controller.c
float PIDCalculate(PIDInstance *pid, float measure, float ref) {
    pid->Ref = ref;          // ä¿å­˜å‚è€ƒå€¼
    pid->Measure = measure;  // ä¿å­˜æµ‹é‡å€¼
    pid->Err = ref - measure; // è®¡ç®—è¯¯å·®
    
    // ... PIDè®¡ç®— ...
    
    pid->Output = Pout + Iout + Dout; // ä¿å­˜è¾“å‡º
    return pid->Output;
}
```

**æ•°æ®æµï¼š**
```
åº”ç”¨å±‚è®¾ç½®
    â†“
DJIMotorSetRef(yaw_motor, ç›®æ ‡è§’åº¦)
    â†“
motor_controller.pid_ref = ç›®æ ‡è§’åº¦
    â†“
DJIMotorControl() è°ƒç”¨
    â†“
PIDCalculate(&angle_PID, IMUè§’åº¦, pid_ref)
    â†“
angle_PID.Ref è¢«æ›´æ–°
```

### 2ï¸âƒ£ `angle_PID.Output` ï¼ˆè§’åº¦ç¯è¾“å‡ºï¼‰

**å«ä¹‰ï¼š** è§’åº¦PIDè®¡ç®—åçš„ç»“æœï¼Œæˆä¸ºé€Ÿåº¦ç¯çš„ç›®æ ‡

**è®¡ç®—å…¬å¼ï¼š**
```
Output = Pout + Iout + Dout
å…¶ä¸­ï¼š
  Pout = Kp Ã— è¯¯å·®
  Iout = Ki Ã— ç§¯åˆ†ç´¯ç§¯
  Dout = Kd Ã— å¾®åˆ†
```

---

## ğŸ” å˜é‡"åœä¸‹æ¥"çš„3ç§åŸå› 

### âŒ åŸå› 1ï¼šç”µæœºè¿›å…¥äº† **ç³»ç»Ÿè¾¨è¯†æ¨¡å¼ï¼ˆSYSIDï¼‰**

**ç°è±¡ï¼š** äº‘å°åœ¨åŠ¨ï¼Œä½† `angle_PID` ä¸æ›´æ–°

**åŸå› ï¼š** 
```c
// application/sysid/sysid_task.c:136
sysid_yaw_motor->motor_settings.close_loop_type = OPEN_LOOP;  // æ”¹ä¸ºå¼€ç¯
sysid_yaw_motor->motor_settings.outer_loop_type = OPEN_LOOP;
```

**è§£é‡Šï¼š**
- åœ¨ç³»ç»Ÿè¾¨è¯†æ¨¡å¼ä¸‹ï¼ŒYAWè½´è¢«è®¾ä¸º**å¼€ç¯æ§åˆ¶**
- å¼€ç¯æ¨¡å¼ä¸‹ï¼Œç›´æ¥å‘é€ç”µæµæŒ‡ä»¤ï¼Œä¸è®¡ç®—PID
- å› æ­¤ `angle_PID.Ref` å’Œ `angle_PID.Output` ä¸å†æ›´æ–°

**ä»£ç é€»è¾‘ï¼š**
```c
// modules/motor/DJImotor/dji_motor.c:257
// åªæœ‰åœ¨é—­ç¯ç±»å‹åŒ…å«ANGLE_LOOPæ—¶æ‰è®¡ç®—è§’åº¦PID
if ((motor_setting->close_loop_type & ANGLE_LOOP) && motor_setting->outer_loop_type == ANGLE_LOOP)
{
    pid_ref = PIDCalculate(&motor_controller->angle_PID, pid_measure, pid_ref);
}
// å¦‚æœæ˜¯OPEN_LOOPï¼Œè¿™æ®µä»£ç ä¸æ‰§è¡Œï¼Œangle_PIDä¸æ›´æ–°ï¼
```

**åˆ¤æ–­æ–¹æ³•ï¼š**
```c
// åœ¨Ozoneä¸­ç›‘æ§ï¼š
yaw_motor->motor_settings.close_loop_type  // å¦‚æœæ˜¯0ï¼ˆOPEN_LOOPï¼‰ï¼Œå°±æ˜¯è¿™ä¸ªåŸå› 
yaw_motor->motor_settings.outer_loop_type  // åº”è¯¥æ˜¯4ï¼ˆANGLE_LOOPï¼‰æ‰æ­£å¸¸
```

---

### âŒ åŸå› 2ï¼šç”µæœºè¢« **åœæ­¢ï¼ˆMOTOR_STOPï¼‰**

**ç°è±¡ï¼š** äº‘å°ä¸åŠ¨ï¼ŒPIDå˜é‡ä¹Ÿä¸æ›´æ–°

**åŸå› ï¼š**
```c
// application/gimbal/gimbal.c:171-172
case GIMBAL_ZERO_FORCE: {
    DJIMotorStop(yaw_motor);  // åœæ­¢ç”µæœº
    DJIMotorStop(pitch_motor);
    break;
}
```

**è§£é‡Šï¼š**
- `DJIMotorStop()` è®¾ç½® `stop_flag = MOTOR_STOP`
- è™½ç„¶PIDè¿˜åœ¨è®¡ç®—ï¼Œä½†æœ€ç»ˆè¾“å‡ºè¢«æ¸…é›¶
- ç”µæœºä¸å“åº”ä»»ä½•æ§åˆ¶

**ä»£ç é€»è¾‘ï¼š**
```c
// modules/motor/DJImotor/dji_motor.c:302-303
// è‹¥è¯¥ç”µæœºå¤„äºåœæ­¢çŠ¶æ€,ç›´æ¥å°†buffç½®é›¶
if (motor->stop_flag == MOTOR_STOP)
    memset(sender_assignment[group].tx_buff + 2 * num, 0, sizeof(uint16_t));
```

**åˆ¤æ–­æ–¹æ³•ï¼š**
```c
// åœ¨Ozoneä¸­ç›‘æ§ï¼š
yaw_motor->stop_flag  // 0=MOTOR_STOPï¼ˆåœæ­¢ï¼‰ï¼Œ1=MOTOR_ENABLEDï¼ˆå¯ç”¨ï¼‰
```

---

### âŒ åŸå› 3ï¼šè°ƒè¯•å™¨é—®é¢˜ - **`yaw_motor` æ˜¯ static å˜é‡**

**ç°è±¡ï¼š** å˜é‡åœ¨è°ƒè¯•å™¨ä¸­ä¸å¯è§æˆ–åœ°å€é”™è¯¯

**åŸå› ï¼š**
```c
// application/gimbal/gimbal.c:24
static DJIMotorInstance *yaw_motor, *pitch_motor;  // staticé™å®šç¬¦
```

**è§£é‡Šï¼š**
- `static` å…³é”®å­—é™åˆ¶äº†å˜é‡çš„å¯è§æ€§
- æŸäº›è°ƒè¯•å™¨å¯èƒ½æ— æ³•æ­£ç¡®è§£æstaticå˜é‡
- ä½ å¯èƒ½ç›‘æ§çš„æ˜¯ä¸€ä¸ªé”™è¯¯çš„åœ°å€æˆ–æ—§çš„å€¼

**è§£å†³æ–¹æ¡ˆï¼š**

**æ–¹æ¡ˆAï¼šåˆ›å»ºå…¨å±€è°ƒè¯•æŒ‡é’ˆï¼ˆæ¨èï¼‰**
```c
// åœ¨ gimbal.c é¡¶éƒ¨æ·»åŠ ï¼ˆéstaticï¼‰
volatile DJIMotorInstance *debug_yaw = NULL;
volatile DJIMotorInstance *debug_pitch = NULL;

// åœ¨ GimbalInit() ä¸­ç»‘å®š
void GimbalInit() {
    // ... ç”µæœºåˆå§‹åŒ– ...
    yaw_motor = DJIMotorInit(&yaw_config);
    pitch_motor = DJIMotorInit(&pitch_config);
    
    // ç»‘å®šè°ƒè¯•æŒ‡é’ˆ
    debug_yaw = yaw_motor;
    debug_pitch = pitch_motor;
}

// åœ¨Ozoneä¸­ç›‘æ§ï¼š
debug_yaw->motor_controller.angle_PID.Ref
debug_yaw->motor_controller.angle_PID.Output
```

**æ–¹æ¡ˆBï¼šç§»é™¤staticé™å®šç¬¦**
```c
// æ”¹ä¸ºéstatic
DJIMotorInstance *yaw_motor, *pitch_motor;
```

---

## ğŸ“Š å®Œæ•´çš„æ§åˆ¶æµç¨‹å›¾

```mermaid
%%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#4a90e2','primaryTextColor':'#000','primaryBorderColor':'#2e5c8a','lineColor':'#4a90e2','secondaryColor':'#50C878','tertiaryColor':'#FFD700','background':'#ffffff','mainBkg':'#f0f0f0','secondBkg':'#e0e0e0','textColor':'#000000','fontSize':'16px'}}}%%
graph TB
    subgraph APP["åº”ç”¨å±‚ (gimbal.c)"]
        A1[é¥æ§å™¨è¾“å…¥] --> A2[DJIMotorSetRef<br/>è®¾ç½® pid_ref]
    end
    
    subgraph CONTROL["æ§åˆ¶å±‚ (dji_motor.c)"]
        A2 --> B1{æ£€æŸ¥ close_loop_type}
        
        B1 -->|åŒ…å« ANGLE_LOOP| B2[PIDCalculate<br/>è§’åº¦ç¯]
        B1 -->|OPEN_LOOP| B3[è·³è¿‡PIDè®¡ç®—<br/>âš ï¸ Refå’ŒOutputä¸æ›´æ–°]
        
        B2 --> B4[æ›´æ–° angle_PID.Ref<br/>æ›´æ–° angle_PID.Output]
        B4 --> B5[pid_ref = Output<br/>ä¼ é€’ç»™é€Ÿåº¦ç¯]
        
        B5 --> C1[PIDCalculate<br/>é€Ÿåº¦ç¯]
        C1 --> C2[æœ€ç»ˆç”µæµæŒ‡ä»¤]
        
        C2 --> D1{æ£€æŸ¥ stop_flag}
        D1 -->|MOTOR_STOP| D2[è¾“å‡ºæ¸…é›¶<br/>ç”µæœºä¸åŠ¨]
        D1 -->|MOTOR_ENABLED| D3[å‘é€CANæŠ¥æ–‡]
    end
    
    subgraph HARDWARE["ç¡¬ä»¶å±‚"]
        D3 --> E1[ç”µæœºè½¬åŠ¨]
        E1 --> E2[IMUåé¦ˆè§’åº¦]
        E2 --> B2
    end
    
    B3 -.->|ç³»ç»Ÿè¾¨è¯†æ¨¡å¼| F1[å¼€ç¯æ§åˆ¶<br/>ç›´æ¥è¾“å‡ºç”µæµ]
    F1 --> E1
    
    style B3 fill:#FF6B6B,stroke:#C92A2A,stroke-width:3px,color:#000
    style D2 fill:#FF6B6B,stroke:#C92A2A,stroke-width:3px,color:#000
    style B4 fill:#50C878,stroke:#2e8b57,stroke-width:2px,color:#000
```

---

## ğŸ”§ è¯Šæ–­æ­¥éª¤

### æ­¥éª¤1ï¼šç¡®è®¤ç”µæœºçŠ¶æ€
åœ¨Ozoneä¸­ç›‘æ§ï¼š
```c
yaw_motor->stop_flag
// 0 = MOTOR_STOPï¼ˆåœæ­¢ï¼‰
// 1 = MOTOR_ENABLEDï¼ˆè¿è¡Œä¸­ï¼‰
```

### æ­¥éª¤2ï¼šç¡®è®¤é—­ç¯ç±»å‹
```c
yaw_motor->motor_settings.close_loop_type
// 0 = OPEN_LOOPï¼ˆå¼€ç¯ï¼Œä¸è®¡ç®—PIDï¼‰
// 2 = SPEED_LOOPï¼ˆé€Ÿåº¦ç¯ï¼‰
// 4 = ANGLE_LOOPï¼ˆè§’åº¦ç¯ï¼‰
// 6 = ANGLE_AND_SPEED_LOOPï¼ˆåŒç¯ä¸²çº§ï¼‰
```

### æ­¥éª¤3ï¼šç¡®è®¤å½“å‰æ¨¡å¼
```c
gimbal_cmd_recv.gimbal_mode
// 0 = GIMBAL_ZERO_FORCEï¼ˆé›¶åŠ›çŸ©ï¼‰
// 1 = GIMBAL_FREE_MODEï¼ˆè‡ªç”±æ¨¡å¼ï¼‰
// 2 = GIMBAL_GYRO_MODEï¼ˆé™€èºä»ªæ¨¡å¼ï¼Œæ­£å¸¸æ¨¡å¼ï¼‰
// 3 = GIMBAL_SYS_ID_CHIRPï¼ˆç³»ç»Ÿè¾¨è¯†æ¨¡å¼ï¼ŒPIDä¸å·¥ä½œï¼ï¼‰
```

### æ­¥éª¤4ï¼šç›‘æ§PIDæ›´æ–°
åŒæ—¶ç›‘æ§è¿™å‡ ä¸ªå˜é‡ï¼š
```c
yaw_motor->motor_controller.angle_PID.Ref      // ç›®æ ‡å€¼
yaw_motor->motor_controller.angle_PID.Measure  // å®é™…å€¼ï¼ˆIMUåé¦ˆï¼‰
yaw_motor->motor_controller.angle_PID.Err      // è¯¯å·®
yaw_motor->motor_controller.angle_PID.Output   // è¾“å‡º
yaw_motor->motor_controller.angle_PID.dt       // PIDè®¡ç®—å‘¨æœŸ
```

å¦‚æœ `dt = 0` æˆ–é•¿æ—¶é—´ä¸å˜ï¼Œè¯´æ˜PIDæ²¡æœ‰åœ¨è®¡ç®—ï¼

---

## ğŸ’¡ å…¸å‹åœºæ™¯åˆ†æ

### åœºæ™¯1ï¼šæ­£å¸¸è¿è¡Œ
```
close_loop_type = 6 (ANGLE_AND_SPEED_LOOP)
outer_loop_type = 4 (ANGLE_LOOP)
stop_flag = 1 (MOTOR_ENABLED)
gimbal_mode = 2 (GIMBAL_GYRO_MODE)

ç»“æœï¼šangle_PID.Ref å’Œ Output æŒç»­æ›´æ–° âœ…
```

### åœºæ™¯2ï¼šç³»ç»Ÿè¾¨è¯†æ¨¡å¼
```
close_loop_type = 0 (OPEN_LOOP)  âš ï¸
outer_loop_type = 0 (OPEN_LOOP)  âš ï¸
stop_flag = 1 (MOTOR_ENABLED)
gimbal_mode = 3 (GIMBAL_SYS_ID_CHIRP)

ç»“æœï¼šangle_PID ä¸æ›´æ–°ï¼Œä½†ç”µæœºåœ¨åŠ¨ï¼ˆå¼€ç¯æ§åˆ¶ï¼‰âŒ
```

### åœºæ™¯3ï¼šç”µæœºåœæ­¢
```
close_loop_type = 6 (ANGLE_AND_SPEED_LOOP)
outer_loop_type = 4 (ANGLE_LOOP)
stop_flag = 0 (MOTOR_STOP)  âš ï¸
gimbal_mode = 0 (GIMBAL_ZERO_FORCE)

ç»“æœï¼šPIDå¯èƒ½è¿˜åœ¨è®¡ç®—ï¼Œä½†è¾“å‡ºè¢«æ¸…é›¶ï¼Œç”µæœºä¸åŠ¨ âŒ
```

---

## ğŸ“ çŸ¥è¯†ç‚¹æ€»ç»“

### 1. PIDå˜é‡çš„æ›´æ–°æ—¶æœº
- `angle_PID.Ref` å’Œ `Output` åªåœ¨ `PIDCalculate()` å‡½æ•°ä¸­æ›´æ–°
- `PIDCalculate()` åªåœ¨æ»¡è¶³é—­ç¯æ¡ä»¶æ—¶è°ƒç”¨
- å¼€ç¯æ¨¡å¼ä¸‹ï¼ŒPIDå®Œå…¨ä¸è®¡ç®—

### 2. æ§åˆ¶æ¨¡å¼çš„åŒºåˆ«
| æ¨¡å¼ | close_loop_type | PIDå·¥ä½œ | é€‚ç”¨åœºæ™¯ |
|------|----------------|---------|---------|
| å¼€ç¯ | OPEN_LOOP (0) | âŒ ä¸å·¥ä½œ | ç³»ç»Ÿè¾¨è¯† |
| é€Ÿåº¦ç¯ | SPEED_LOOP (2) | ä»…é€Ÿåº¦PID | é€Ÿåº¦æ§åˆ¶ |
| è§’åº¦ç¯ | ANGLE_LOOP (4) | ä»…è§’åº¦PID | ä½ç½®æ§åˆ¶ |
| åŒç¯ä¸²çº§ | ANGLE_AND_SPEED_LOOP (6) | âœ… å…¨éƒ¨å·¥ä½œ | æ­£å¸¸äº‘å°æ§åˆ¶ |

### 3. staticå˜é‡çš„è°ƒè¯•é—®é¢˜
- `static` å˜é‡åªåœ¨å½“å‰æ–‡ä»¶å¯è§
- éƒ¨åˆ†è°ƒè¯•å™¨æ— æ³•ç›´æ¥è®¿é—®staticå˜é‡
- è§£å†³æ–¹æ¡ˆï¼šåˆ›å»ºéstaticçš„å…¨å±€è°ƒè¯•æŒ‡é’ˆ

---

## âœ… è§£å†³å»ºè®®

### å¦‚æœæ˜¯ç³»ç»Ÿè¾¨è¯†æ¨¡å¼å¯¼è‡´ï¼š
1. é€€å‡ºç³»ç»Ÿè¾¨è¯†æ¨¡å¼ï¼Œåˆ‡æ¢åˆ° `GIMBAL_GYRO_MODE`
2. æˆ–è€…åœ¨Ozoneä¸­ç›‘æ§å¼€ç¯æ§åˆ¶çš„å˜é‡ï¼ˆç”µæµæŒ‡ä»¤ï¼‰

### å¦‚æœæ˜¯è°ƒè¯•å™¨é—®é¢˜ï¼š
1. åˆ›å»ºå…¨å±€è°ƒè¯•æŒ‡é’ˆï¼ˆè§ä¸Šæ–¹æ–¹æ¡ˆAï¼‰
2. æˆ–ç§»é™¤staticé™å®šç¬¦

### æ¨èçš„Ozoneç›‘æ§é…ç½®ï¼š
```
// åŸºç¡€çŠ¶æ€
yaw_motor->stop_flag
yaw_motor->motor_settings.close_loop_type
yaw_motor->motor_settings.outer_loop_type

// PIDçŠ¶æ€ï¼ˆä»…åœ¨é—­ç¯æ¨¡å¼æœ‰æ•ˆï¼‰
yaw_motor->motor_controller.angle_PID.Ref
yaw_motor->motor_controller.angle_PID.Measure
yaw_motor->motor_controller.angle_PID.Err
yaw_motor->motor_controller.angle_PID.Output
yaw_motor->motor_controller.angle_PID.dt

// é€Ÿåº¦ç¯
yaw_motor->motor_controller.speed_PID.Output

// æœ€ç»ˆè¾“å‡º
yaw_motor->measure.real_current
```

---

**æ–‡æ¡£ç”Ÿæˆæ—¶é—´ï¼š** 2025-10-10


