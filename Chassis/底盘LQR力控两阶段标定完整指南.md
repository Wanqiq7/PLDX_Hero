# 底盘LQR力控两阶段标定完整指南 🎯

> 架空辨识LQR → 落地整定摩擦补偿 = 完美底盘控制

## 🎯 标定策略总览

### 为什么分两阶段？

**核心思想**：**分离电机特性和地面摩擦**

```
【阶段1】架空辨识
目的：获得纯电机动力学参数
条件：轮子悬空，无地面摩擦
输出：LQR增益 K_velocity
用途：处理电机惯量和电机阻尼

【阶段2】落地整定
目的：补偿地面摩擦
条件：轮子接地，正常运行
输出：摩擦补偿电流 FRICTION_STATIC/DYNAMIC
用途：消除地面摩擦的影响
```

### 物理模型分解

```
总控制电流 = LQR基础电流 + 摩擦补偿电流

I_total = I_lqr(架空辨识) + I_friction(落地整定)
          ↑                 ↑
    处理电机动力学      补偿地面摩擦
```

---

## 🔧 阶段1：架空系统辨识

### 目标

获得**纯电机特性**的LQR增益，消除地面摩擦干扰。

### 详细步骤

#### 1.1 架起机器人（5分钟）

**方法选择**：

**方法A：全架空**（推荐）
```
使用支架/木块架起底盘
  ↓
四个轮子全部悬空
  ↓
优点：测试任意一个轮子
```

**方法B：边缘悬空**
```
将底盘放在桌边
  ↓
一个轮子悬空
  ↓
优点：简单，无需支架
缺点：只能测试一个轮子
```

**方法C：侧倒架空**
```
将底盘侧放（小心）
  ↓
一侧两个轮子悬空
  ↓
优点：稳定
缺点：需要两人操作
```

**安全检查**：
- [ ] 支架稳固，不会倾倒
- [ ] 轮子完全悬空（离地>2cm）
- [ ] 周围无障碍物
- [ ] 电池固定牢靠

#### 1.2 配置系统辨识

**在 `sysid_task.c` 中设置**：
```c
#define CHASSIS_SYS_ID_TARGET_MOTOR 0  // 选择左前轮
#define CHASSIS_SYS_ID_STEP_AMPLITUDE 5000.0f  // 电流幅值（架空可用较小值）
```

**建议**：架空状态用较小电流（3000-5000），避免高速空转。

#### 1.3 Ozone配置

**记录变量**（1kHz）：
```
sysid_data.time_elapsed
sysid_data.step_input
sysid_data.motor_output
sysid_data.task_freq  // 验证采样率
```

#### 1.4 执行辨识测试

```
1. 启动Ozone录制
2. 触发系统辨识（enable=1）
3. 等待20秒（轮子会正反转）
4. 停止录制
5. 导出CSV文件

预期现象：
  - 轮子按2秒间隔正反转
  - 轮速快速跟随电流变化
  - 几乎无延迟（因为无摩擦）
```

#### 1.5 MATLAB分析

```matlab
cd Chassis
Chassis_Wheel_SysID

% 选择CSV文件
% 选择数据区间（建议选择中间5-6个周期）
% 等待计算完成
```

**预期输出**（架空状态）：
```
辨识物理参数（单轮）:
  J_eff = 0.001180 kg·m²        ← 转动惯量
  b_eff = 0.009245 N·m·s/rad    ← 电机阻尼（较小！）
  拟合度 = 94.8%                ← 应该很高

推算整车阻尼（架空状态，仅供参考）:
  b_linear ≈ 10.45 N·s/m        ← 仅电机贡献
  b_angular ≈ 1.38 N·m·s/rad

LQR增益（基于架空辨识）:
  K_velocity = 132.5 N/(m/s)    ← 复制到代码！
  K_velocity = 45.2 N·m/(rad/s)
```

**关键观察**：
- ✅ b_eff应该较小（0.008-0.012），因为无地面摩擦
- ✅ 拟合度应该很高（>90%），因为无干扰
- ✅ LQR增益K较小（因为阻尼小）

#### 1.6 配置LQR参数

```c
// 复制MATLAB输出到 chassis.c 的 ChassisInit()

LQR_Velocity_Init_Config_s force_x_lqr_config = {
    .K_velocity = 132.5f,  // ← 架空辨识得到
    .K_integral = 6.6f,
    .max_out = 150.0f,
    .enable_integral = 1,
    .integral_limit = 20.0f,
    .integral_deadband = 0.01f,
    .integral_decay_coef = 0.3f,
};
```

#### 1.7 架空验证测试

```
编译烧录 → 保持架空状态测试

遥控器控制 → 轮子应该：
  ✅ 快速响应
  ✅ 速度跟随准确
  ✅ 无震荡
```

**通过标准**：架空状态下LQR控制良好

---

## 🔧 阶段2：落地摩擦整定

### 目标

在实际运行条件下，整定`ForceToCurrentConversion()`函数中的**摩擦补偿参数**。

### 为什么需要摩擦补偿？

**落地后的变化**：
```
架空：F_total = F_motor（只有电机阻尼）
      I_needed = F_motor / (Kt * ratio / r)
      
落地：F_total = F_motor + F_ground_friction（增加地面摩擦！）
      I_needed = (F_motor + F_friction) / (Kt * ratio / r)
                           ↑
                    这部分需要额外补偿
```

**如果不补偿**：
- ❌ 低速时启动困难（克服不了静摩擦）
- ❌ 零速时抖动（摩擦力不连续）
- ❌ 速度偏低（动摩擦消耗能量）

### 详细步骤

#### 2.1 放下机器人
```
将机器人从支架上放下
  ↓
四轮接触地面
  ↓
LQR参数保持不变（使用阶段1的K_velocity）
```

#### 2.2 初步测试（默认摩擦补偿）

```c
// 当前使用的默认值
FRICTION_STATIC_CURRENT = 0.8f
FRICTION_DYNAMIC_CURRENT = 0.5f
```

**操作**：遥控器缓慢推动，目标速度0.15 m/s

**观察现象**：

✅ **现象A：底盘平稳启动**
```
→ 摩擦补偿基本合适
→ 跳到步骤2.4微调
```

❌ **现象B：底盘不动或启动很慢**
```
原因：静摩擦补偿不足
→ 进入步骤2.3增大静摩擦补偿
```

❌ **现象C：底盘抖动**
```
原因：补偿不连续
→ 进入步骤2.5调整过渡参数
```

#### 2.3 整定静摩擦补偿

**方法：渐进增大法**

```c
// robot_def.h中逐步修改
#define FRICTION_STATIC_CURRENT 0.8f  // 测试1：不动
                                ↓ 增大0.2
#define FRICTION_STATIC_CURRENT 1.0f  // 测试2：仍不动
                                ↓ 增大0.2
#define FRICTION_STATIC_CURRENT 1.2f  // 测试3：能动了！
                                ↓ 略微增大
#define FRICTION_STATIC_CURRENT 1.3f  // 测试4：平稳启动 ✅
```

**每次修改后**：
```bash
make clean && make -j8  # 编译
# 烧录测试
```

**确定标准**：
- 目标速度0.1 m/s时，底盘能在100ms内启动
- 无明显延迟或顿挫感

#### 2.4 整定动摩擦补偿

**测试中等速度**：

```
操作：遥控器给0.8 m/s目标速度，保持不变

Ozone监控：
  chassis_force_x_lqr.velocity_error  // 速度误差
  
调整规则：
  - 误差>+0.03 m/s（实际速度低）→ 增大DYNAMIC
  - 误差<-0.03 m/s（实际速度高）→ 减小DYNAMIC
  - |误差|<0.02 m/s → 合适 ✅
```

**调整示例**：
```c
// 初始值
#define FRICTION_DYNAMIC_CURRENT 0.5f
测试 → 速度偏低0.06 m/s
         ↓
#define FRICTION_DYNAMIC_CURRENT 0.7f  // 增大
测试 → 速度偏低0.02 m/s
         ↓
#define FRICTION_DYNAMIC_CURRENT 0.75f // 再增大一点
测试 → 速度精确！ ✅
```

**经验公式**：
```c
FRICTION_DYNAMIC_CURRENT = FRICTION_STATIC_CURRENT * (0.6 ~ 0.75)
```

#### 2.5 优化过渡参数（可选）

**问题**：零速附近有抖动

**测试**：
```
操作：遥控器非常缓慢推动（0.05 m/s）

观察：速度曲线是否平滑
```

**调整方案A：加大过渡窗口**
```c
#define FRICTION_LINEAR_WINDOW (8.0f * DEGREE_2_RAD)  // 从5度→8度

效果：过渡更平滑，但可能略微损失低速响应
```

**调整方案B：降低阈值**
```c
#define FRICTION_THRESHOLD_OMEGA (8.0f * DEGREE_2_RAD)  // 从10度→8度

效果：更早进入动摩擦，减少过渡区抖动
```

#### 2.6 全速段验证

**完整测试**：
```
1. 低速（0.1 m/s）   → 检查启动平滑性
2. 中速（0.8 m/s）   → 检查速度精度
3. 高速（2.0 m/s）   → 检查稳定性
4. 变速（0→1→0 m/s） → 检查过渡
5. 方向切换          → 检查对称性
```

**通过标准**：
- [ ] 所有速度段响应平滑
- [ ] 稳态误差<0.02 m/s
- [ ] 无抖动无震荡
- [ ] 加减速线性
- [ ] 前后左右对称

---

## 📊 参数整定速查表

### 现象 → 调整方案

| 现象 | 原因 | 调整参数 | 方向 |
|------|------|----------|------|
| 低速不启动 | 静摩擦不足 | `FRICTION_STATIC_CURRENT` | ⬆️ +0.2 |
| 低速抖动 | 过渡不平滑 | `FRICTION_LINEAR_WINDOW` | ⬆️ 加大 |
| 中速偏低 | 动摩擦不足 | `FRICTION_DYNAMIC_CURRENT` | ⬆️ +0.1 |
| 中速偏高 | 动摩擦过大 | `FRICTION_DYNAMIC_CURRENT` | ⬇️ -0.1 |
| 零速漂移 | 静摩擦过大 | `FRICTION_STATIC_CURRENT` | ⬇️ -0.1 |
| 全速段震荡 | LQR增益过大 | `K_velocity` | ⬇️ *0.8 |
| 响应太慢 | LQR增益过小 | `K_velocity` | ⬆️ *1.2 |

---

## 🎮 实战案例

### 案例：标准步兵，普通地面

**阶段1：架空辨识**

```
硬件：用两个木块架起底盘
测试：左前轮辨识
结果：
  J_eff = 0.001165 kg·m²
  b_eff = 0.009125 N·m·s/rad  ← 注意很小（无地面摩擦）
  拟合度 = 93.7%              ← 很高
  
  K_velocity = 131.8 N/(m/s)  ← 配置到代码
```

**阶段2：落地整定**

```
初始参数（默认）：
  FRICTION_STATIC_CURRENT = 0.8f
  FRICTION_DYNAMIC_CURRENT = 0.5f

测试1 - 低速启动(0.15 m/s)：
  现象：底盘起步延迟300ms
  结论：静摩擦不足
  调整：STATIC → 1.1f
  
测试2 - 重测低速：
  现象：平稳启动 ✅
  
测试3 - 中速运行(0.8 m/s)：
  Ozone: velocity_error = +0.05 m/s
  结论：动摩擦不足
  调整：DYNAMIC → 0.7f
  
测试4 - 重测中速：
  Ozone: velocity_error = +0.01 m/s ✅
  
测试5 - 零速检查：
  现象：无抖动 ✅

最终参数：
  FRICTION_STATIC_CURRENT = 1.1f   ✅
  FRICTION_DYNAMIC_CURRENT = 0.7f  ✅
```

**性能表现**：
- 上升时间：115 ms
- 超调量：3.2%
- 稳态误差：0.009 m/s
- 低速平滑度：⭐⭐⭐⭐⭐

---

## 📈 架空 vs 落地数据对比

### 辨识结果对比

| 参数 | 架空辨识 | 落地辨识（如果做） | 差异 |
|------|----------|-------------------|------|
| b_eff | 0.009 N·m·s/rad | 0.022 N·m·s/rad | +144% |
| 拟合度 | 94.8% | 78.3% | -17% |
| K_velocity | 132 N/(m/s) | 187 N/(m/s) | +42% |

**结论**：
- ✅ 架空辨识：拟合度高，参数准确
- ⚠️ 落地辨识：包含地面摩擦，拟合度降低

**推荐做法**：
- ✅ 用架空辨识得到LQR增益
- ✅ 用落地整定得到摩擦补偿
- ❌ 不推荐直接落地辨识（拟合度低）

---

## 🔬 技术原理

### 为什么架空辨识更准确？

**动力学模型**：
```
架空：J * dω/dt = τ_motor - b_motor * ω
                  ↑          ↑
              电机驱动    电机阻尼（小）

落地：J * dω/dt = τ_motor - b_motor * ω - F_ground * r
                  ↑          ↑             ↑
              电机驱动    电机阻尼      地面摩擦（大！）
```

**系统辨识**：
```
架空：只需辨识 b_motor → 简单，准确
落地：需辨识 b_motor + F_ground → 复杂，F_ground非线性
```

**地面摩擦的非线性特性**：
```
F_ground = {
    μ_s * N,  v = 0      (静摩擦)
    μ_d * N,  v > v_th   (动摩擦)
    ...复杂过渡区...
}
    ↑
非线性！不适合线性系统辨识
```

**结论**：
- ✅ 架空辨识 → 线性系统 → 准确
- ❌ 落地辨识 → 非线性系统 → 拟合差
- ✅ 两阶段法 → 分离处理 → 最优 🏆

---

## 🛠️ 完整工具链

### 工具1：系统辨识脚本

**文件**：`Chassis_Wheel_SysID.m`

**用途**：阶段1，架空辨识LQR增益

**输入**：Ozone CSV（架空测试数据）

**输出**：LQR配置代码

### 工具2：摩擦补偿整定

**文档**：`摩擦补偿参数整定指南.md`

**用途**：阶段2，落地整定摩擦参数

**方法**：
- 方法1：最小推动力法
- 方法2：速度阶跃响应法
- 方法3：自动标定法

### 工具3：实时监控（Ozone）

**关键变量**：
```
阶段1（架空）：
  sysid_data.motor_output  // 轮速应快速跟随

阶段2（落地）：
  chassis_force_x_lqr.velocity_error  // 速度误差
  wheel_current[0]  // 电流（包含摩擦补偿）
```

---

## ✅ 两阶段标定检查清单

### 阶段1：架空辨识 ✅

- [ ] 机器人已架起，轮子悬空
- [ ] 已运行系统辨识任务
- [ ] 已导出CSV数据
- [ ] 已运行Chassis_Wheel_SysID.m
- [ ] 拟合度>85%
- [ ] 已复制K_velocity到代码
- [ ] 已编译烧录
- [ ] 架空状态测试通过

### 阶段2：落地整定 ✅

- [ ] 机器人已放下，正常放置
- [ ] 默认摩擦补偿测试完成
- [ ] 低速启动测试(0.1 m/s) - 平滑
- [ ] 中速精度测试(0.8 m/s) - 误差<0.02
- [ ] 高速稳定测试(2.0 m/s) - 无震荡
- [ ] 零速抖动测试 - 无抖动
- [ ] 全速段验证通过
- [ ] 最终参数已确定

---

## 📊 预期整定结果

### 最终参数示例

**地面：普通地面**
```c
// LQR增益（阶段1辨识）
.K_velocity = 132.5f  // N/(m/s)，架空辨识

// 摩擦补偿（阶段2整定）
#define FRICTION_STATIC_CURRENT 1.1f   // A，落地整定
#define FRICTION_DYNAMIC_CURRENT 0.7f  // A，落地整定
```

**地面：光滑地板**
```c
.K_velocity = 128.3f  // 阻尼稍小

#define FRICTION_STATIC_CURRENT 0.7f   // 摩擦小
#define FRICTION_DYNAMIC_CURRENT 0.4f
```

**地面：地毯**
```c
.K_velocity = 135.8f  // 阻尼稍大

#define FRICTION_STATIC_CURRENT 1.6f   // 摩擦大
#define FRICTION_DYNAMIC_CURRENT 1.0f
```

---

## 🎯 性能预期

### 两阶段标定后

| 性能指标 | 目标值 | 实测（示例） |
|---------|--------|-------------|
| 低速启动(0.1m/s) | <100ms | 65ms ✅ |
| 零速稳定 | 无抖动 | 完美 ✅ |
| 中速精度(0.8m/s) | <0.02m/s | 0.009m/s ✅ |
| 高速稳定(2.0m/s) | 无震荡 | 稳定 ✅ |
| 上升时间 | <150ms | 118ms ✅ |
| 超调量 | <10% | 3.5% ✅ |

### 与单阶段对比

| 方法 | 拟合度 | K准确性 | 低速性能 | 总性能 |
|------|--------|---------|----------|--------|
| 仅架空辨识 | 95% | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |
| 仅落地辨识 | 78% | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **两阶段标定** | 95%+整定 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | **⭐⭐⭐⭐⭐** |

---

## 💡 高级技巧

### 技巧1：多地面自适应

**标定表**：
```c
// 建立摩擦补偿查找表
const float friction_table[][2] = {
    // {static, dynamic}
    {0.7f, 0.4f},  // 光滑地板
    {1.1f, 0.7f},  // 普通地面
    {1.6f, 1.0f},  // 地毯
};

// 运行时根据地面类型切换
int surface_type = detect_surface();  // 通过速度衰减率检测
FRICTION_STATIC = friction_table[surface_type][0];
```

### 技巧2：在线微调

```c
// 根据速度误差在线微调动摩擦
if (steady_state) {
    float error_avg = average(velocity_error, 100);  // 100个采样平均
    if (fabsf(error_avg) > 0.03f) {
        // 误差持续存在，微调摩擦补偿
        FRICTION_DYNAMIC_CURRENT += error_avg * 0.1f;
    }
}
```

### 技巧3：四轮独立标定

```c
// 为每个轮子设置不同的摩擦补偿
#define FRICTION_COMP_LF 1.05f  // 左前
#define FRICTION_COMP_RF 1.10f  // 右前（可能略大）
#define FRICTION_COMP_LB 1.08f  // 左后
#define FRICTION_COMP_RB 1.12f  // 右后

// 在ForceToCurrentConversion()中使用
```

---

## 📝 标定记录模板

建议保存每次标定的参数：

```
日期：2025-01-04
地点：训练场A区
地面：普通水泥地
天气：晴天，干燥

【阶段1：架空辨识】
  测试轮子：左前轮
  J_eff: 0.001165 kg·m²
  b_eff: 0.009245 N·m·s/rad
  拟合度：93.7%
  K_velocity: 132.5 N/(m/s)

【阶段2：落地整定】
  静摩擦：0.8 → 1.0 → 1.1f ✅
  动摩擦：0.5 → 0.7f ✅
  过渡窗口：5° → 8° ✅

【性能验证】
  低速启动：优秀（<80ms）
  中速精度：±0.009 m/s
  零速抖动：无
  
【备注】
  温度：电机温度<50°C
  功耗：正常
```

---

## 🎓 总结

### 两阶段标定的科学性

```
分离关注点 (Separation of Concerns)

架空辨识 → 电机本征特性
  ✅ 线性系统
  ✅ 高拟合度
  ✅ 参数可靠

落地整定 → 环境摩擦补偿
  ✅ 针对性强
  ✅ 补偿精确
  ✅ 性能最优

合并使用 → 完美控制
  I = I_lqr(架空辨识) + I_friction(落地整定)
```

### 优势总结

1. **辨识准确** - 架空消除干扰，拟合度>90%
2. **补偿精确** - 落地针对实际地面标定
3. **性能最优** - 两者结合，发挥各自优势
4. **可维护性** - 两阶段独立，方便调试

### 适用场景

特别适合：
- ✅ 需要极致性能的场景
- ✅ 地面条件复杂多变
- ✅ 对低速控制要求高
- ✅ 有充足时间标定

---

## 📚 相关文档

### 阶段1相关
- `底盘系统辨识完整流程.md` - 详细辨识教程
- `底盘系统辨识快速参考.md` - 速查手册
- `Chassis_Wheel_SysID.m` - MATLAB脚本

### 阶段2相关
- `摩擦补偿参数整定指南.md` - 详细整定方法
- 本文档 - 两阶段完整流程

### 理论基础
- `底盘LQR力控使用指南.md` - LQR原理
- `LQR力控策略实现总结.md` - 系统架构

---

## 🚀 立即开始

### 快速启动（首次标定）

```
今天：
  1. ✅ 架起机器人
  2. ✅ 运行Chassis_Wheel_SysID.m（15分钟）
  3. ✅ 配置K_velocity到代码

明天：
  1. ✅ 放下机器人
  2. ✅ 整定摩擦补偿（30分钟）
  3. ✅ 验证性能

总耗时：约1小时
性能提升：30-50%
```

### 后续优化（可选）

```
下周：
  - 多地面标定
  - 建立补偿表

下月：
  - 实现自适应
  - 在线微调
```

---

**你现在拥有了最专业的底盘标定方法！** 🏆

**分两阶段标定 = 科学 + 精确 = 卓越性能！** 🚀

---

**实施日期**: 2025-01-04  
**方法创新**: 两阶段分离标定  
**适用版本**: Chassis v2.0 (LQR力控)  
**推荐度**: ⭐⭐⭐⭐⭐

