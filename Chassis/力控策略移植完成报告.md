# 力控策略移植完成报告

## 📋 移植概述

本次移植成功将 **robowalker2024bottominfantry-main** 中的力控策略移植到 **Chassis** 底盘控制代码中。移植遵循了robowalker的核心思想：**速度PID输出力/扭矩而非速度，通过动力学模型实现更精确的底盘控制**。

## ✅ 完成的工作

### 1. 参数定义 (`robot_def.h`)

添加了力控策略所需的物理参数：

```c
/* ----------------力控策略相关物理参数---------------- */
#define M3508_TORQUE_CONSTANT 0.3f              // 电机转矩常数 (N·m/A)
#define M3508_CMD_TO_CURRENT_COEFF (20.0f / 16384.0f)  // CAN指令到电流转换系数
#define FRICTION_STATIC_CURRENT 0.8f            // 静摩擦补偿电流
#define FRICTION_DYNAMIC_CURRENT 0.5f           // 动摩擦补偿电流
#define FRICTION_THRESHOLD_OMEGA (10.0f * DEGREE_2_RAD)  // 摩擦补偿阈值
#define FRICTION_LINEAR_WINDOW (5.0f * DEGREE_2_RAD)     // 零点连续化窗口
#define MAX_CONTROL_FORCE 150.0f                // 最大控制力 (N)
#define MAX_CONTROL_TORQUE 40.0f                // 最大控制扭矩 (N·m)
#define MAX_WHEEL_CURRENT 10.0f                 // 单轮最大电流 (A)
```

### 2. 力控PID控制器 (`chassis.c`)

添加了三个核心PID控制器：

- **chassis_force_x_pid**: X方向力控PID (输出单位: N)
- **chassis_force_y_pid**: Y方向力控PID (输出单位: N)  
- **chassis_torque_pid**: 旋转扭矩PID (输出单位: N·m)

**初始化参数**：
```c
// X/Y方向力控PID
Kp = 80.0f, Ki = 2.0f, Kd = 0.0f
MaxOut = 150.0f (N)

// 旋转扭矩PID
Kp = 35.0f, Ki = 1.0f, Kd = 0.0f
MaxOut = 40.0f (N·m)
```

### 3. 核心函数实现

#### 3.1 速度估算 (`EstimateChassisVelocity`)
- 基于麦轮逆运动学，从四个电机速度反推底盘速度
- 使用一阶低通滤波平滑估算结果
- 为后续升级到卡尔曼滤波预留接口

#### 3.2 速度→力转换 (`VelocityToForceControl`)
**核心思想**：速度PID输出力/扭矩而非速度
```c
// PID输出的是需要的合力(N)和合扭矩(N·m)
force_x = PIDCalculate(&chassis_force_x_pid, chassis_estimated_vx, target_vx);
force_y = PIDCalculate(&chassis_force_y_pid, chassis_estimated_vy, target_vy);
torque_z = PIDCalculate(&chassis_torque_pid, chassis_estimated_wz, target_wz);
```

#### 3.3 力的动力学逆解算 (`ForceDynamicsInverseResolution`)
将底盘合力分配到各个轮子：
```c
// 麦轮力分配矩阵
wheel_force[0] = (-force_x - force_y) / 4.0f - torque_z / (4.0f * rotation_radius);  // 左前
wheel_force[1] = (-force_x + force_y) / 4.0f + torque_z / (4.0f * rotation_radius);  // 右前
wheel_force[2] = (force_x - force_y) / 4.0f + torque_z / (4.0f * rotation_radius);   // 左后
wheel_force[3] = (force_x + force_y) / 4.0f - torque_z / (4.0f * rotation_radius);   // 右后
```

#### 3.4 力→电流转换 + 摩擦补偿 (`ForceToCurrentConversion`)
**核心创新**：零点连续化摩擦补偿，避免震荡
```c
// 基础转换: I = F * r / (K_t * reduction_ratio)
float base_current = wheel_force[i] * RADIUS_WHEEL / 
                    (M3508_TORQUE_CONSTANT * REDUCTION_RATIO_WHEEL);

// 零点连续化摩擦补偿
if (|ω| > 阈值)        → 动摩擦补偿
else if (|ω| > 窗口)   → 线性插值过渡
else if (|ω| > 0)      → 连续化静摩擦
else                   → 无补偿

// 总电流 = 基础电流 + 摩擦补偿
wheel_current[i] = base_current + friction_comp;
```

### 4. 主控制流程集成 (`ChassisTask`)

完整的力控流程：
```c
// 1. 速度闭环 → 力/扭矩
VelocityToForceControl();

// 2. 力的动力学逆解算
ForceDynamicsInverseResolution();

// 3. 力→电流转换 + 摩擦补偿
ForceToCurrentConversion();

// 4. 下发电机电流指令
DJIMotorSetRef(motor_lf, wheel_current[0] / M3508_CMD_TO_CURRENT_COEFF);
DJIMotorSetRef(motor_rf, wheel_current[1] / M3508_CMD_TO_CURRENT_COEFF);
DJIMotorSetRef(motor_lb, wheel_current[2] / M3508_CMD_TO_CURRENT_COEFF);
DJIMotorSetRef(motor_rb, wheel_current[3] / M3508_CMD_TO_CURRENT_COEFF);
```

## 🎯 力控策略的核心优势

### 1. 物理建模更精确
- 基于牛顿第二定律 (F = ma)
- 直接控制力/扭矩，物理意义明确
- 更符合底盘实际动力学特性

### 2. 摩擦补偿更先进
- **零点连续化**：避免传统死区方法的震荡问题
- 三段式补偿：静摩擦→过渡区→动摩擦
- 物理上更合理，控制更平滑

### 3. 低速/零速性能优异
- 力控可在零速时施加精确的静摩擦补偿
- 速控在零速附近容易震荡，需要设置死区
- 适合需要精确定位的场景

### 4. 抗扰动能力强
- 外力扰动直接反映在力平衡上
- 控制器可快速响应
- 对抗激烈时抗冲撞能力更强

## 🔧 调试指南

### 1. 首次启动建议

**降低PID参数进行保守测试**：
```c
// 保守参数（首次测试）
force_x/y_pid: Kp = 40.0f, Ki = 0.5f
torque_pid:    Kp = 15.0f, Ki = 0.2f
```

### 2. 参数标定步骤

#### 步骤1：电机转矩常数标定
```c
// 方法：空载测试
// 1. 固定电流，记录加速度
// 2. 根据 τ = K_t * I 和 τ = J * α 计算
// 当前值：M3508_TORQUE_CONSTANT = 0.3 (N·m/A)
```

#### 步骤2：摩擦补偿标定
```c
// 方法：最小推动力测试
// 1. 缓慢增大电流，记录底盘开始移动的最小电流
// 2. 该电流即为静摩擦补偿值
// 当前值：
FRICTION_STATIC_CURRENT = 0.8f  // 待实测调整
FRICTION_DYNAMIC_CURRENT = 0.5f // 待实测调整
```

#### 步骤3：PID参数调整
```
优先级：Kp > Ki > Kd

1. 只调Kp，从小到大：
   - 太小：响应慢
   - 太大：震荡
   - 合适：快速跟踪无震荡

2. 再调Ki（消除稳态误差）：
   - 太小：稳态误差大
   - 太大：积分饱和/超调
   - 推荐：Kp的1/40~1/20

3. Kd一般不需要（噪声敏感）
```

### 3. 分阶段测试

**测试顺序**：
1. ✅ **固定电流测试**：验证电机电流控制正常
2. ✅ **开环力测试**：给定恒定force_x，检查是否直线运动
3. ✅ **速度环测试**：小幅度运动，逐步调PID
4. ✅ **摩擦补偿测试**：低速区间观察响应平滑性
5. ✅ **完整功能测试**：遥控器控制，各方向运动

### 4. 常见问题排查

| 现象 | 可能原因 | 解决方案 |
|------|----------|----------|
| 底盘不动 | 摩擦补偿太小 | 增大FRICTION_STATIC_CURRENT |
| 震荡严重 | Kp太大 | 降低Kp，增加积分限幅 |
| 响应慢 | Kp太小 | 适当增大Kp |
| 低速抖动 | 摩擦补偿不连续 | 检查FRICTION_LINEAR_WINDOW |
| 零速漂移 | 积分饱和 | 减小Ki或增大IntegralLimit |

## 📊 与原速控策略对比

| 对比项 | 力控策略 | 原速控策略 |
|--------|----------|------------|
| 控制对象 | 力/扭矩 | 速度 |
| PID输出 | 牛顿(N) | 角度/秒(°/s) |
| 物理建模 | 动力学 | 运动学 |
| 摩擦补偿 | 力层直接补偿，零点连续化 | 速度/电流层补偿 |
| 低速性能 | 优秀 | 一般（死区问题） |
| 调参难度 | 较高（需标定物理参数） | 中等 |
| 代码复杂度 | 高（三层转换） | 中（一层转换） |

## 🚀 后续优化方向

### 1. 速度估算优化
```c
// 当前：简单的电机反馈 + 一阶滤波
// 升级：卡尔曼滤波融合IMU和电机数据
EstimateChassisVelocity() → KalmanFilterUpdate()
```

### 2. 自适应摩擦补偿
```c
// 根据实际速度误差在线学习摩擦参数
void AdaptiveFrictionLearning() {
    if (steady_state && has_velocity_error) {
        FRICTION_STATIC_CURRENT += learning_rate * error;
    }
}
```

### 3. 功率限制集成
```c
// 基于力的功率预测
float predicted_power = Σ(wheel_current[i] * motor_speed[i]);
if (predicted_power > limit) {
    scale_all_wheel_current(limit / predicted_power);
}
```

### 4. 斜坡补偿
```c
// 检测斜坡角度，添加重力分量补偿
void SlopeForceCompensation() {
    float slope_force = CHASSIS_MASS * GRAVITY * sin(pitch_angle);
    force_x += slope_force; // 添加到控制力中
}
```

## 📝 注意事项

### ⚠️ 重要提醒

1. **电机模式检查**：确保电机配置为电流控制模式（当前代码已配置）

2. **参数标定必须**：以下参数必须根据实际机器人标定：
   - `M3508_TORQUE_CONSTANT`
   - `FRICTION_STATIC_CURRENT`
   - `FRICTION_DYNAMIC_CURRENT`

3. **保守调参**：首次测试时降低PID参数，逐步增大

4. **安全限制**：已设置多重限幅保护，但仍需注意：
   ```c
   MAX_CONTROL_FORCE = 150.0f      // 底盘合力限制
   MAX_CONTROL_TORQUE = 40.0f      // 底盘扭矩限制
   MAX_WHEEL_CURRENT = 10.0f       // 单轮电流限制
   ```

5. **速度估算精度**：当前为简化估算，后续建议升级为卡尔曼滤波

## 📚 参考资料

- **robowalker2024bottominfantry-main/test/User_File/3_Chariot/1_Module/Chassis/**
  - `crt_chassis.cpp`: 力控策略核心实现
  - `crt_chassis.h`: 舵轮底盘结构定义

- **理论基础**：
  - 牛顿第二定律：F = ma
  - 电机动力学：τ = K_t * I
  - 麦轮运动学：力分配矩阵

## ✅ 移植完成检查清单

- [x] robot_def.h 添加物理参数
- [x] chassis.c 添加PID控制器声明
- [x] 实现 EstimateChassisVelocity()
- [x] 实现 VelocityToForceControl()
- [x] 实现 ForceDynamicsInverseResolution()
- [x] 实现 ForceToCurrentConversion()
- [x] ChassisInit 添加PID初始化
- [x] ChassisTask 集成力控流程
- [x] 代码注释完整
- [x] 编写移植报告

---

**移植完成日期**: 2025-01-04  
**移植人员**: AI Assistant  
**代码规范**: 符合APP层应用编写指引.md  
**测试状态**: 待实机测试调参

## 🎉 总结

本次移植成功将robowalker的力控思想引入Chassis底盘控制，实现了从速度控制到力控制的升级。核心创新在于**让PID输出物理量（力/扭矩）而非运动量（速度）**，配合零点连续化的摩擦补偿，理论上可实现更精确、更平滑的底盘控制。

下一步需要在实际机器人上进行参数标定和调试验证。

