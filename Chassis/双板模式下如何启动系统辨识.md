# 双板模式下如何启动底盘系统辨识

## 🎯 问题澄清

当前配置：`CHASSIS_BOARD`（底盘板）

```
硬件连接：
  云台板 ← 遥控器（有接收器）
     ↕️ CAN通信
  底盘板 ← 电机（无遥控器）
```

**关键问题**：底盘板没有遥控器，如何触发系统辨识？

---

## ✅ 解决方案（3种）

### 方案1：自动触发（最简单）⭐⭐⭐⭐⭐

**完全不需要遥控器！**

#### 代码实现

在 `Chassis/application/chassis/chassis.c` 中添加：

```c
#include "sysid_task.h"
#include "user_lib.h"

// ========== 自动触发系统辨识 ==========
static Publisher_t *auto_sysid_pub = NULL;
static uint8_t auto_sysid_done = 0;

static void AutoStartSysID() {
    if (auto_sysid_done) return;
    
    // 上电5秒后自动触发
    if (DWT_GetTimeline_s() > 5.0f) {
        if (!auto_sysid_pub) {
            auto_sysid_pub = PubRegister("chassis_sysid_cmd", 
                                         sizeof(Chassis_SysID_Ctrl_Cmd_s));
        }
        
        Chassis_SysID_Ctrl_Cmd_s cmd = {
            .enable = 1,        // 启动
            .target_motor = 0,  // 左前轮
        };
        PubPushMessage(auto_sysid_pub, &cmd);
        auto_sysid_done = 1;
    }
}
```

在 `ChassisTask()` 中调用：
```c
void ChassisTask() {
    AutoStartSysID();  // 自动触发
    
    // ... 原有代码 ...
}
```

#### 使用流程

```
1. 架起机器人
2. 配置Ozone
3. 编译烧录底盘板
4. 启动Ozone录制
5. 上电 → 等5秒 → 自动开始
6. 等20秒 → 自动结束
7. 导出CSV
```

**优点**：
- ✅ 无需遥控器
- ✅ 无需云台板
- ✅ 最简单
- ✅ 适合首次测试

**缺点**：
- ⚠️ 每次上电都触发（需测试完删除代码）

---

### 方案2：宏开关触发（推荐）⭐⭐⭐⭐⭐

**通过修改宏定义控制，无需遥控器！**

#### 代码实现

在 `Chassis/application/chassis/chassis.c` 开头添加：

```c
// ========== 系统辨识控制开关 ==========
#define ENABLE_CHASSIS_SYSID 0  // ← 改为1启动，改为0停止
#define SYSID_TARGET_MOTOR 0    // ← 选择电机：0-lf, 1-rf, 2-lb, 3-rb

#if ENABLE_CHASSIS_SYSID
static Publisher_t *sysid_switch_pub = NULL;
static uint8_t sysid_switch_triggered = 0;

static void SysIDSwitch() {
    if (sysid_switch_triggered) return;
    
    if (DWT_GetTimeline_s() > 3.0f) {  // 上电3秒后
        if (!sysid_switch_pub) {
            sysid_switch_pub = PubRegister("chassis_sysid_cmd", 
                                            sizeof(Chassis_SysID_Ctrl_Cmd_s));
        }
        
        Chassis_SysID_Ctrl_Cmd_s cmd = {
            .enable = 1,
            .target_motor = SYSID_TARGET_MOTOR,
        };
        PubPushMessage(sysid_switch_pub, &cmd);
        sysid_switch_triggered = 1;
    }
}
#endif
```

在 `ChassisTask()` 中：
```c
void ChassisTask() {
#if ENABLE_CHASSIS_SYSID
    SysIDSwitch();  // 如果宏为1，则触发
#endif
    
    // ... 原有代码 ...
}
```

#### 使用流程

```
【测试时】
1. 修改宏：#define ENABLE_CHASSIS_SYSID 1
2. 编译烧录
3. 上电 → 自动启动辨识

【测试完成后】
1. 修改宏：#define ENABLE_CHASSIS_SYSID 0
2. 编译烧录
3. 恢复正常运行
```

**优点**：
- ✅ 无需遥控器
- ✅ 开关清晰
- ✅ 可选择任意电机
- ✅ 代码可永久保留

**推荐**：这是最好的方案！

---

### 方案3：通过CAN从云台板触发（复杂）⭐⭐

**需要云台板和底盘板协同**

#### 实现思路

**云台板端**（有遥控器）：
```c
// 在云台板的robot_cmd.c中
void RobotCMDTask() {
    // 遥控器触发
    if (左拨杆中 && 右拨杆下) {
        // 通过CAN发送辨识指令到底盘板
        Chassis_Ctrl_Cmd_s chassis_cmd = {
            .chassis_mode = CHASSIS_SYSID_MODE,  // 需要新增模式
            // ...
        };
        CANCommSend(can_comm, &chassis_cmd);
    }
}
```

**底盘板端**：
```c
// 在底盘板的chassis.c中
void ChassisTask() {
    // 接收云台板指令
    chassis_cmd_recv = *(Chassis_Ctrl_Cmd_s *)CANCommGet(chasiss_can_comm);
    
    // 检测辨识模式
    if (chassis_cmd_recv.chassis_mode == CHASSIS_SYSID_MODE) {
        // 触发辨识
        Chassis_SysID_Ctrl_Cmd_s cmd = {.enable = 1, .target_motor = 0};
        PubPushMessage(sysid_pub, &cmd);
    }
}
```

**缺点**：
- ⚠️ 需要修改云台板代码
- ⚠️ 需要新增CAN通信协议
- ⚠️ 复杂度高

**不推荐**：除非你确实需要从云台板控制

---

## 🎯 强烈推荐：方案2（宏开关）

### 完整实现代码

**复制到 chassis.c 的开头**（include之后）：

```c
// ========================================================================
// 系统辨识控制开关（测试完成后设为0即可，代码可永久保留）
// ========================================================================
#define ENABLE_CHASSIS_SYSID 0  // 0-关闭，1-启动辨识
#define SYSID_TARGET_MOTOR 0    // 0-lf, 1-rf, 2-lb, 3-rb

#if ENABLE_CHASSIS_SYSID
static Publisher_t *sysid_switch_pub = NULL;
static uint8_t sysid_switch_done = 0;

/**
 * @brief 系统辨识开关函数
 * @note 当ENABLE_CHASSIS_SYSID=1时，上电3秒后自动启动辨识
 */
static void ChassisSystemIDSwitch() {
    if (sysid_switch_done) return;
    
    // 延迟3秒，确保系统稳定
    if (DWT_GetTimeline_s() > 3.0f) {
        // 首次调用，注册发布者
        if (sysid_switch_pub == NULL) {
            sysid_switch_pub = PubRegister("chassis_sysid_cmd", 
                                            sizeof(Chassis_SysID_Ctrl_Cmd_s));
        }
        
        // 发布启动指令
        Chassis_SysID_Ctrl_Cmd_s sysid_cmd = {
            .enable = 1,
            .target_motor = SYSID_TARGET_MOTOR,
        };
        PubPushMessage(sysid_switch_pub, &sysid_cmd);
        
        sysid_switch_done = 1;  // 标记已触发
        
        // 可选：打印日志（如果启用了LOG）
        // LOGINFO("[SysID] Auto-triggered for motor %d", SYSID_TARGET_MOTOR);
    }
}
#endif
// ========================================================================
```

**在 ChassisTask() 中调用**：

```c
void ChassisTask() {
#if ENABLE_CHASSIS_SYSID
    ChassisSystemIDSwitch();  // 辨识开关
#endif
    
    // 后续增加没收到消息的处理(双板的情况)
    // 获取新的控制信息
#ifdef ONE_BOARD
    SubGetMessage(chassis_sub, &chassis_cmd_recv);
#endif
#ifdef CHASSIS_BOARD
    chassis_cmd_recv = *(Chassis_Ctrl_Cmd_s *)CANCommGet(chasiss_can_comm);
#endif // CHASSIS_BOARD
    
    // ... 原有代码继续 ...
}
```

### 使用方法

#### 启动辨识测试

```c
// 1. 修改宏开关
#define ENABLE_CHASSIS_SYSID 1  // ← 改为1

// 2. 选择测试电机
#define SYSID_TARGET_MOTOR 0  // 0-左前，1-右前，2-左后，3-右后

// 3. 编译烧录
make clean && make -j8

// 4. 架起机器人，配置Ozone，上电测试
```

#### 测试完成后

```c
// 只需改一个数字
#define ENABLE_CHASSIS_SYSID 0  // ← 改回0

// 编译烧录，恢复正常运行
make clean && make -j8
```

#### 测试其他轮子

```c
// 改目标电机
#define SYSID_TARGET_MOTOR 1  // 测试右前轮

// 编译烧录，重复测试
```

---

## 📊 三种方案对比

| 方案 | 需要遥控器 | 需要云台板 | 复杂度 | 灵活性 | 推荐度 |
|------|-----------|-----------|--------|--------|--------|
| **宏开关触发** | ❌ 不需要 | ❌ 不需要 | ⭐ 简单 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 自动触发 | ❌ 不需要 | ❌ 不需要 | ⭐ 简单 | ⭐⭐ | ⭐⭐⭐⭐ |
| CAN触发 | ✅ 需要 | ✅ 需要 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |

---

## 🎯 最佳实践（双板模式）

### 推荐流程

**✅ 使用方案2（宏开关触发）**

**理由**：
1. 不需要遥控器
2. 不需要修改云台板
3. 开关清晰（改个数字）
4. 代码可永久保留
5. 支持测试任意电机

### 完整操作步骤

```
┌─────────────────────────────────┐
│ 1. 在chassis.c添加宏开关代码      │
│    （复制上面的完整代码）          │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 2. 修改宏：ENABLE_CHASSIS_SYSID=1│
│    选择电机：SYSID_TARGET_MOTOR=0│
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 3. 编译烧录底盘板                 │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 4. 架起机器人（轮子悬空）         │
│    配置Ozone记录                 │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 5. 启动Ozone录制                 │
│    给底盘板上电                   │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 6. 等待3秒 → 自动启动辨识         │
│    等待20秒 → 自动结束            │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 7. Ozone导出CSV                  │
│    运行Chassis_Wheel_SysID.m     │
└──────────┬──────────────────────┘
           ↓
┌─────────────────────────────────┐
│ 8. 修改宏：ENABLE_CHASSIS_SYSID=0│
│    编译烧录，恢复正常              │
└─────────────────────────────────┘
```

---

## 💡 为什么方案2最好？

### 对比分析

**方案1（自动触发）**：
```
优点：简单
缺点：每次上电都触发，测试完必须删除代码
```

**方案2（宏开关）**：
```
优点：
  - 改个数字就能开关
  - 代码可永久保留
  - 清晰可控
  - 支持快速切换测试不同电机
  
缺点：无
```

**方案3（CAN触发）**：
```
优点：可用遥控器控制
缺点：
  - 需要改云台板代码
  - 需要增加CAN协议
  - 复杂
```

### 实际使用场景

**场景1：首次辨识**
```
方案2最佳：
  1. ENABLE_CHASSIS_SYSID=1，MOTOR=0（左前）
  2. 测试
  3. ENABLE_CHASSIS_SYSID=0
```

**场景2：测试4个轮子**
```
方案2最佳：
  循环：
    MOTOR=0 → 编译烧录 → 测试 → 导出数据
    MOTOR=1 → 编译烧录 → 测试 → 导出数据
    MOTOR=2 → 编译烧录 → 测试 → 导出数据
    MOTOR=3 → 编译烧录 → 测试 → 导出数据
  最后：ENABLE=0 → 编译烧录 → 完成
```

**场景3：现场快速重测**
```
方案2最佳：
  ENABLE=1 → 编译烧录 → 测试
  ENABLE=0 → 编译烧录 → 恢复
  
  只需改一个数字！
```

---

## 🔧 如果坚持用遥控器怎么办？

### 需要做的改动

**选项A：临时把遥控器接到底盘板**
```
硬件：
  1. 拔下云台板上的遥控器接收器
  2. 接到底盘板的对应串口
  3. 测试完改回来
  
软件：
  1. 底盘板需要初始化遥控器模块
  2. 添加遥控器触发逻辑
  3. 测试完改回来
  
评价：麻烦，不推荐 ❌
```

**选项B：双板CAN通信触发**
```
云台板：遥控器 → 发CAN指令
底盘板：接收CAN → 触发辨识

需要修改：
  - 云台板robot_cmd.c（加触发逻辑）
  - 底盘板chassis.c（解析CAN指令）
  - 可能需要修改CAN协议
  
评价：复杂，除非必须，否则不推荐 ⚠️
```

---

## ✅ 我的建议

**强烈建议使用方案2（宏开关）！**

### 理由

1. **无需遥控器** - 底盘板本来就没有
2. **无需云台板** - 完全独立
3. **简单可靠** - 改个数字就行
4. **永久保留** - 代码不需要删除
5. **灵活切换** - 可快速测试不同电机

### 完整代码示例

我已经在上面"方案2"中提供了完整的复制粘贴代码。

**操作超级简单**：
```
测试时：ENABLE_CHASSIS_SYSID = 1
测试完：ENABLE_CHASSIS_SYSID = 0

就这么简单！
```

---

## 🎬 立即开始（方案2示例）

### 1. 复制这段代码到 chassis.c

```c
// 在 #include "user_lib.h" 之后添加

// ============================================================
// 系统辨识宏开关（测试时改为1，完成后改为0）
// ============================================================
#define ENABLE_CHASSIS_SYSID 1  // ← 启动辨识时改为1
#define SYSID_TARGET_MOTOR 0    // ← 0-lf, 1-rf, 2-lb, 3-rb

#if ENABLE_CHASSIS_SYSID
static Publisher_t *sysid_macro_pub = NULL;
static uint8_t sysid_macro_done = 0;

static void MacroTriggerSysID() {
    if (sysid_macro_done) return;
    if (DWT_GetTimeline_s() > 3.0f) {
        if (!sysid_macro_pub) {
            sysid_macro_pub = PubRegister("chassis_sysid_cmd", 
                                          sizeof(Chassis_SysID_Ctrl_Cmd_s));
        }
        Chassis_SysID_Ctrl_Cmd_s cmd = {
            .enable = 1,
            .target_motor = SYSID_TARGET_MOTOR,
        };
        PubPushMessage(sysid_macro_pub, &cmd);
        sysid_macro_done = 1;
    }
}
#endif
// ============================================================
```

### 2. 在 ChassisTask() 开头添加

```c
void ChassisTask() {
#if ENABLE_CHASSIS_SYSID
    MacroTriggerSysID();
#endif
    
    // ... 原有代码 ...
}
```

### 3. 使用

```bash
# 启动测试
# 只需改这一行：
#define ENABLE_CHASSIS_SYSID 1

make clean && make -j8
# 烧录，上电3秒后自动启动

# 测试完恢复
# 只需改这一行：
#define ENABLE_CHASSIS_SYSID 0

make clean && make -j8
```

---

## 🎉 总结

### 核心答案

**问题**：双板模式下底盘板没有遥控器，如何触发系统辨识？

**答案**：**不需要遥控器！用宏开关触发！**

```
❌ 不需要拆遥控器
❌ 不需要改云台板
✅ 只需要在底盘板chassis.c添加宏开关
✅ 改个数字（0/1）就能控制
```

### 立即行动

1. 📖 打开 `chassis.c`
2. 📝 复制上面"方案2"的完整代码
3. 🔧 设置 `ENABLE_CHASSIS_SYSID = 1`
4. 💻 编译烧录
5. 🧪 架起机器人测试

**就这么简单！完全不需要动遥控器！** ✅

---

**文档更新**: 2025-01-04  
**问题**: 双板模式下如何触发  
**方案**: 宏开关触发（最优）

