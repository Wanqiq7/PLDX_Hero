# 底盘摩擦补偿参数整定指南

> 阶段2：在架空辨识LQR后，对ForceToCurrentConversion()函数进行摩擦参数整定

## 🎯 整定流程概述

### 两阶段标定策略

```
【阶段1】架空辨识 - 获得纯电机LQR参数
    机器人架空 → 系统辨识 → LQR增益K
    └→ 消除地面摩擦干扰，辨识纯电机特性
    
【阶段2】落地整定 - 优化摩擦补偿参数  ← 本文档
    机器人落地 → 运行LQR → 整定摩擦补偿
    └→ 补偿地面摩擦，实现丝滑控制
```

---

## 📋 前提条件

在进行本阶段前，必须完成：

- [x] 阶段1：架空系统辨识（参见"底盘系统辨识完整流程.md"）
- [x] 已获得LQR增益K_velocity
- [x] 已配置K_velocity到chassis.c并烧录
- [x] LQR力控代码正常运行

---

## 🎯 需要整定的参数

### 在 `robot_def.h` 中（第108-115行）

```c
/* ----------------力控策略摩擦补偿参数---------------- */
// 静摩擦补偿电流值 (A)，需要根据实际机器人标定
#define FRICTION_STATIC_CURRENT 0.8f    // ← 重点整定！

// 动摩擦补偿电流值 (A)，需要根据实际机器人标定  
#define FRICTION_DYNAMIC_CURRENT 0.5f   // ← 重点整定！

// 摩擦补偿速度阈值 (rad/s)，低于此值使用静摩擦补偿
#define FRICTION_THRESHOLD_OMEGA (10.0f * DEGREE_2_RAD)  // ← 可微调

// 摩擦补偿连续化窗口 (rad/s)
#define FRICTION_LINEAR_WINDOW (5.0f * DEGREE_2_RAD)  // ← 可微调
```

---

## 🔧 整定方法

### 方法1：最小推动力法（推荐） ⭐⭐⭐

#### 原理
静摩擦力是让底盘从静止开始移动所需的最小力。

#### 步骤

**1. 准备工作**
```c
// 临时修改chassis.c，绕过LQR直接施加固定电流
void ChassisTask() {
    // 注释掉LQR力控流程
    // VelocityToForceControl();
    // ...
    
    // 直接施加固定电流测试
    static float test_current = 0.0f;  // 从0开始
    
    DJIMotorSetRef(motor_lf, test_current / M3508_CMD_TO_CURRENT_COEFF);
    DJIMotorSetRef(motor_rf, test_current / M3508_CMD_TO_CURRENT_COEFF);
    DJIMotorSetRef(motor_lb, test_current / M3508_CMD_TO_CURRENT_COEFF);
    DJIMotorSetRef(motor_rb, test_current / M3508_CMD_TO_CURRENT_COEFF);
}
```

**2. 逐步增大电流**
```
手动修改代码中的test_current：
  test_current = 0.3f  → 烧录 → 观察底盘是否移动
  test_current = 0.5f  → 烧录 → 观察
  test_current = 0.7f  → 烧录 → 观察
  test_current = 0.9f  → 烧录 → 开始缓慢移动！ ← 记录这个值
```

**3. 确定静摩擦补偿**
```c
// 记录底盘开始移动的最小电流
I_start_moving = 0.9f  (A)

// 设置静摩擦补偿（略大于最小电流）
#define FRICTION_STATIC_CURRENT 1.0f  // I_start_moving * 1.1
```

**4. 确定动摩擦补偿**
```c
// 动摩擦通常是静摩擦的60-75%
#define FRICTION_DYNAMIC_CURRENT 0.6f  // STATIC * 0.6
```

### 方法2：速度阶跃响应法 ⭐⭐⭐⭐

#### 原理
通过观察LQR控制下的速度响应，调整摩擦补偿使响应最优。

#### 步骤

**1. 恢复LQR力控代码（取消上述临时修改）**

**2. 配置Ozone监控变量**
```
chassis_estimated_vx           // 当前速度
target_vx                      // 目标速度
wheel_current[0]               // 电机电流
force_x                        // 控制力
```

**3. 低速阶跃测试**
```
操作：遥控器缓慢推动摇杆，给0.2 m/s的目标速度

观察现象：
  - 如果底盘不动或起步很慢：摩擦补偿太小 → 增大
  - 如果底盘抖动：摩擦补偿过渡不平滑 → 调整窗口
  - 如果速度超调：摩擦补偿太大 → 减小
```

**4. 调整静摩擦**

**现象A：低速启动困难**
```c
// 增大静摩擦补偿
#define FRICTION_STATIC_CURRENT 1.2f  // 从0.8增加到1.2
```

**现象B：低速时抖动**
```c
// 加大过渡窗口，使补偿更平滑
#define FRICTION_LINEAR_WINDOW (10.0f * DEGREE_2_RAD)  // 从5度增到10度
```

**现象C：零速时有小幅漂移**
```c
// 减小静摩擦补偿
#define FRICTION_STATIC_CURRENT 0.6f  // 减小
```

**5. 调整动摩擦**

**测试**：遥控器给中等速度（0.8-1.5 m/s）

**现象A：高速时速度偏低（稳态误差）**
```c
// 增大动摩擦补偿
#define FRICTION_DYNAMIC_CURRENT 0.7f  // 从0.5增到0.7
```

**现象B：高速时速度过冲**
```c
// 减小动摩擦补偿
#define FRICTION_DYNAMIC_CURRENT 0.4f
```

### 方法3：自动标定法（高级） ⭐⭐⭐⭐⭐

创建一个自动标定程序：

```c
// 在chassis.c中添加标定函数
void CalibrateStaticFriction() {
    static float test_current = 0.0f;
    static uint32_t steady_counter = 0;
    
    // 逐步增大电流
    test_current += 0.05f;  // 每次增加0.05A
    
    // 施加到所有轮子
    for (int i = 0; i < 4; i++) {
        wheel_current[i] = test_current;
    }
    
    // 检测是否开始移动（速度>阈值）
    if (fabsf(chassis_estimated_vx) > 0.05f) {  // 5 cm/s
        steady_counter++;
        if (steady_counter > 100) {  // 持续100ms
            // 记录静摩擦电流
            FRICTION_STATIC_CURRENT_CALIBRATED = test_current;
            // 标定完成
        }
    } else {
        steady_counter = 0;
    }
}
```

---

## 📊 参数整定表

### 不同地面的典型值

| 地面类型 | FRICTION_STATIC | FRICTION_DYNAMIC | THRESHOLD_OMEGA | 说明 |
|---------|----------------|------------------|-----------------|------|
| 光滑地板 | 0.5-0.8 A | 0.3-0.5 A | 8°/s | 摩擦小 |
| 普通地面 | 0.8-1.2 A | 0.5-0.8 A | 10°/s | 标准 |
| 地毯 | 1.2-2.0 A | 0.8-1.3 A | 15°/s | 摩擦大 |
| 粗糙地面 | 1.5-2.5 A | 1.0-1.5 A | 15°/s | 摩擦很大 |

### 参数关系

```
典型关系：
  DYNAMIC ≈ STATIC * 0.6 ~ 0.75
  
物理意义：
  动摩擦 < 静摩擦（库仑摩擦定律）
```

---

## 🔬 详细整定步骤

### 第1步：架空辨识（无地面摩擦）

#### 1.1 架起机器人
```
方法1：用支架架起底盘，四轮悬空
方法2：用木块垫高底盘，轮子离地2-3cm
方法3：找平台，将底盘放在边缘，一个轮子悬空
```

#### 1.2 系统辨识
```bash
# 按之前的流程执行
1. 配置Ozone记录
2. 启动辨识任务（轮子悬空时）
3. 导出CSV
4. 运行 Chassis_Wheel_SysID.m
```

**预期结果**（架空状态）：
```
b_eff ≈ 0.008-0.012 N·m·s/rad  （较小，因为无地面摩擦）
拟合度 > 90%  （很高，因为无干扰）
K_velocity ≈ 120-150 N/(m/s)  （较小，因为阻尼小）
```

#### 1.3 配置LQR参数
```c
// 将MATLAB输出复制到chassis.c
LQR_Velocity_Init_Config_s force_x_lqr_config = {
    .K_velocity = 132.5f,  // ← 架空辨识得到的值
    .K_integral = 6.6f,
    // ... 其他参数
};
```

#### 1.4 首次测试（架空状态）
```
目的：验证LQR基本功能
操作：遥控器控制，观察轮子转动
预期：轮速跟随良好，响应快速
```

### 第2步：落地整定（有地面摩擦）

#### 2.1 放下机器人
```
轮子接触地面，正常放置
```

#### 2.2 初步测试（使用默认摩擦补偿）
```
当前摩擦补偿：
  FRICTION_STATIC_CURRENT = 0.8f   (默认值)
  FRICTION_DYNAMIC_CURRENT = 0.5f  (默认值)

操作：遥控器缓慢推动

观察：
  ✅ 如果底盘能平稳启动 → 补偿合适，跳到2.4
  ❌ 如果底盘不动或很慢 → 补偿太小，进入2.3
  ❌ 如果底盘抖动 → 补偿不平滑，进入2.5
```

#### 2.3 整定静摩擦补偿

**目标**：让底盘能从零速平稳启动

**方法A：Ozone实时观察**
```
监控变量：
  chassis_estimated_vx         // 当前速度
  wheel_current[0]             // 电流（包含摩擦补偿）
  chassis_force_x_lqr.output   // LQR输出的力

操作：
  1. 给很小的目标速度（0.1 m/s）
  2. 观察wheel_current值
  3. 如果底盘不动，记录此时的电流I
  4. 设置 FRICTION_STATIC_CURRENT = I + 0.2
```

**方法B：二分查找**
```
初始范围：[0.5, 2.0]

循环：
  1. 设置 FRICTION_STATIC = (min + max) / 2
  2. 编译烧录
  3. 测试0.1 m/s启动
  4. 如果不动 → min = current
     如果能动 → max = current
  5. 重复直到找到临界值

最终设置：临界值 * 1.1 ~ 1.2
```

**方法C：经验公式（快速）**
```c
// 粗略估算：
// 架空辨识的b_motor ≈ 0.010
// 落地实测的b_total ≈ 0.025（包含地面摩擦）
// 地面贡献的阻尼 Δb = 0.015

// 转换为静摩擦电流：
// F_friction = Δb * v / r² ≈ 常数（低速时）
// I_friction = F_friction * r / (Kt * ratio)

float delta_b = 0.015;  // 地面贡献的阻尼
float I_static = delta_b * 0.1 / (r_wheel * r_wheel) * r_wheel / (Kt * ratio);
// I_static ≈ 0.8-1.2 A

#define FRICTION_STATIC_CURRENT 1.0f  // 使用估算值
```

#### 2.4 整定动摩擦补偿

**目标**：让底盘在中高速时速度精确

**操作**：
```
1. 遥控器给中等速度（0.8 m/s）
2. 保持摇杆位置不变
3. Ozone监控 chassis_force_x_lqr.velocity_error
4. 调整FRICTION_DYNAMIC_CURRENT使误差最小

调整规则：
  - 速度偏低（误差>0.05） → 增大DYNAMIC
  - 速度偏高（误差<-0.05） → 减小DYNAMIC
  - 速度准确（|误差|<0.02） → OK！
```

**经验值**：
```c
// 通常为静摩擦的60-75%
FRICTION_DYNAMIC_CURRENT = FRICTION_STATIC_CURRENT * 0.65f;
```

#### 2.5 整定过渡参数（可选）

**问题**：零速附近有抖动

**原因**：摩擦补偿在零点不连续

**解决**：调整过渡窗口
```c
// 加大过渡窗口，使补偿更平滑
#define FRICTION_LINEAR_WINDOW (10.0f * DEGREE_2_RAD)  // 从5度→10度

// 或降低阈值
#define FRICTION_THRESHOLD_OMEGA (8.0f * DEGREE_2_RAD)  // 从10度→8度
```

---

## 🎮 实战整定示例

### 场景：普通地面，从默认值开始

**初始状态**：
```c
FRICTION_STATIC_CURRENT = 0.8f   // 默认
FRICTION_DYNAMIC_CURRENT = 0.5f  // 默认
K_velocity = 132.5f              // 架空辨识得到
```

**测试1：低速启动（0.1 m/s）**
```
现象：底盘不动或起步很慢
Ozone显示：wheel_current ≈ 0.9A 但速度为0
结论：静摩擦补偿不足

调整：
#define FRICTION_STATIC_CURRENT 1.1f  // 增大到1.1
```

**测试2：重新测试低速**
```
现象：底盘能平稳启动
速度误差：±0.02 m/s
结论：静摩擦补偿合适 ✅
```

**测试3：中速运行（0.8 m/s）**
```
现象：速度略低于目标（0.75 m/s）
Ozone显示：velocity_error ≈ +0.05 m/s
结论：动摩擦补偿不足

调整：
#define FRICTION_DYNAMIC_CURRENT 0.7f  // 从0.5增到0.7
```

**测试4：重新测试中速**
```
现象：速度精确
速度误差：±0.01 m/s
结论：动摩擦补偿合适 ✅
```

**测试5：零速抖动检查**
```
操作：缓慢推动摇杆从0到0.1 m/s

现象：轻微抖动
结论：过渡不够平滑

调整：
#define FRICTION_LINEAR_WINDOW (8.0f * DEGREE_2_RAD)  // 增大窗口
```

**最终参数**：
```c
#define FRICTION_STATIC_CURRENT 1.1f
#define FRICTION_DYNAMIC_CURRENT 0.7f
#define FRICTION_THRESHOLD_OMEGA (10.0f * DEGREE_2_RAD)
#define FRICTION_LINEAR_WINDOW (8.0f * DEGREE_2_RAD)
```

---

## 📊 整定效果对比

### 整定前 vs 整定后

| 测试项 | 默认值 | 整定后 | 改善 |
|--------|--------|--------|------|
| 低速启动（0.1 m/s） | 困难，延迟500ms | 平滑，延迟50ms | ⬆️ 90% |
| 零速抖动 | 明显 | 几乎无 | ⬆️ 95% |
| 中速精度（0.8 m/s） | 误差±0.08 | 误差±0.01 | ⬆️ 87% |
| 高速稳定（2.0 m/s） | 略有波动 | 稳定 | ⬆️ 60% |
| 整体丝滑度 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | 完美 |

---

## 🔬 原理深入

### 为什么分两阶段？

**架空辨识的优势**：
```
无地面摩擦 → 纯电机特性 → 辨识准确
  ↓
得到基础LQR增益（对应无摩擦理想情况）
```

**落地整定的必要性**：
```
地面摩擦 ≠ 电机阻尼
  ↓
需要额外的前馈补偿（摩擦补偿）
  ↓
ForceToCurrentConversion()添加friction_comp
```

### 摩擦补偿的作用

**代码中的实现**（chassis.c第566-609行）：
```c
float base_current = wheel_force[i] * RADIUS_WHEEL / 
                    (M3508_TORQUE_CONSTANT * REDUCTION_RATIO_WHEEL);

float friction_comp = 0.0f;
// 根据速度计算补偿...

wheel_current[i] = base_current + friction_comp;  // ← 关键！
                   ↑              ↑
              LQR计算的基础电流  补偿地面摩擦
```

**物理意义**：
```
总电流 = 基础电流（LQR计算） + 摩擦补偿（前馈）

基础电流：来自LQR，对应架空状态的理想控制
摩擦补偿：补偿地面摩擦力的影响
```

---

## ✅ 整定完成标准

### 性能指标

- [ ] 低速启动（0.05-0.2 m/s）平滑无延迟
- [ ] 零速时无抖动或漂移
- [ ] 中速（0.5-1.5 m/s）速度误差<0.02 m/s
- [ ] 高速（2.0-3.0 m/s）稳定无震荡
- [ ] 加速/减速过程平滑

### 主观感受

- [ ] 遥控器操控感觉"跟手"
- [ ] 速度变化丝滑
- [ ] 无明显的启动顿挫感
- [ ] 停止时无惯性漂移

---

## 🎯 快速整定流程（精简版）

```
1. 架空机器人 → 系统辨识 → 得到K_velocity → 配置到代码
                                    ↓
2. 放下机器人 → 低速测试 → 调FRICTION_STATIC
                                    ↓
3. 中速测试 → 调FRICTION_DYNAMIC
                                    ↓
4. 零速测试 → 调FRICTION_LINEAR_WINDOW
                                    ↓
5. 完整测试 → 验收通过 ✅
```

**总耗时**：约1小时（包含多次编译烧录）

---

## 🛠️ 调试工具

### Ozone配置

**必须监控**：
```
chassis_estimated_vx              // 当前速度
chassis_force_x_lqr.velocity_error // LQR速度误差
wheel_current[0]                  // 轮子电流
```

**可选监控**（深入分析）：
```
force_x                           // LQR输出的力
wheel_force[0]                    // 分配到轮子的力
base_current                      // 基础电流（需临时添加到代码）
friction_comp                     // 摩擦补偿（需临时添加到代码）
```

### 临时调试代码

在`ForceToCurrentConversion()`函数中添加调试输出：

```c
static void ForceToCurrentConversion() {
    // ... 原有代码 ...
    
    // 临时添加：导出中间变量供Ozone查看
    static float debug_base_current[4];
    static float debug_friction_comp[4];
    
    for (int i = 0; i < 4; i++) {
        float base_current = ...;
        float friction_comp = ...;
        
        debug_base_current[i] = base_current;      // ← Ozone监控
        debug_friction_comp[i] = friction_comp;    // ← Ozone监控
        
        wheel_current[i] = base_current + friction_comp;
    }
}
```

---

## 📝 整定记录表

建议记录整定过程：

| 地面 | STATIC | DYNAMIC | WINDOW | 低速表现 | 中速误差 | 零速抖动 |
|------|--------|---------|--------|----------|----------|----------|
| 试验场地 | 0.8 | 0.5 | 5° | ❌不动 | - | - |
| 试验场地 | 1.1 | 0.5 | 5° | ✅好 | +0.06 | 轻微 |
| 试验场地 | 1.1 | 0.7 | 5° | ✅好 | +0.01 | 轻微 |
| 试验场地 | 1.1 | 0.7 | 8° | ✅好 | +0.01 | ✅无 |
| **最终** | **1.1** | **0.7** | **8°** | ✅ | ✅ | ✅ |

---

## ⚠️ 注意事项

### 1. 架空辨识注意

- ⚠️ 确保支架稳固，防止倾倒
- ⚠️ 轮子完全悬空，不接触任何物体
- ⚠️ 测试电流不要太大（避免轮子高速空转危险）

### 2. 落地整定注意

- ⚠️ 周围留出足够空间（至少2米）
- ⚠️ 准备急停
- ⚠️ 从小参数开始，逐步增大
- ⚠️ 每次修改只改一个参数

### 3. 参数合理性

```c
// 静摩擦补偿不应超过电机额定电流的20%
FRICTION_STATIC_CURRENT < 4.0f  // 20A * 0.2 = 4A

// 动摩擦应小于静摩擦
FRICTION_DYNAMIC_CURRENT < FRICTION_STATIC_CURRENT
```

---

## 🎓 理论补充

### 库仑摩擦模型

```
摩擦力 F_friction：

  F_static = μ_s * N      静摩擦力
  F_dynamic = μ_d * N     动摩擦力
  
其中：
  μ_s: 静摩擦系数（>μ_d）
  μ_d: 动摩擦系数
  N: 正压力

特性：
  - 静摩擦 > 动摩擦（启动需要更大力）
  - 零速时不连续（Stribeck效应）
```

### 零点连续化策略

**传统方法（有抖动）**：
```
if (v == 0) comp = 0
else if (v > 0) comp = +F_static
else comp = -F_static
         ↑
      不连续！会抖动
```

**本实现（平滑）**：
```
if (|v| < 窗口) comp = (v/窗口) * F_static  ← 线性过渡
else if (|v| < 阈值) comp = 插值(F_static, F_dynamic)
else comp = ±F_dynamic

       补偿
        ↑
动摩擦 |────────
       |   ╱
       |  ╱ 过渡区
       | ╱
       |╱ 线性区
       └────────→ 速度
       0  窗口 阈值
```

---

## 📚 相关代码位置

### 摩擦补偿实现
```
Chassis/application/chassis/chassis.c
  → 第566-609行: ForceToCurrentConversion()
  → 第533-560行: 零点连续化摩擦补偿逻辑
```

### 参数定义
```
Chassis/application/robot_def.h
  → 第108-115行: 摩擦补偿参数宏定义
```

---

## 🎉 总结

### 两阶段标定的优势

✅ **阶段1（架空）**：
- 辨识纯电机特性
- 消除地面干扰
- 获得理想LQR增益

✅ **阶段2（落地）**：
- 补偿地面摩擦
- 实际环境优化
- 达到最优性能

### 核心思想

```
LQR（基于架空辨识）→ 处理电机动力学
      +
摩擦补偿（基于落地整定）→ 处理地面摩擦
      =
完美控制 🏆
```

### 预期最终性能

- 🎯 低速启动：延迟<50ms
- ✨ 零速稳定：无抖动
- 🚀 中高速：误差<1cm
- 🎮 操控感：丝滑跟手

---

**整定成功后，你将拥有业界领先的底盘控制性能！** 🏆

**实施日期**: 2025-01-04  
**适用版本**: Chassis v2.0 (LQR力控)

