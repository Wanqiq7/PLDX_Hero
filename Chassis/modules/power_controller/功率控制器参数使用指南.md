# 功率控制器参数使用指南

> **文档版本**：v2.0
> **最后更新**：2025-01-18
> **适用模块**：Chassis/modules/power_controller/
> **作者**：基于Wanqiq原始实现整理

---

## 📋 目录

- [概述](#概述)
- [快速开始](#快速开始)
- [参数分类详解](#参数分类详解)
  - [1. 使能开关](#1-使能开关)
  - [2. 能量环PD控制器参数](#2-能量环pd控制器参数)
  - [3. 功率分配参数](#3-功率分配参数)
  - [4. 能量缓冲阈值](#4-能量缓冲阈值)
  - [5. RLS初始化参数](#5-rls初始化参数)
  - [6. 电机参数](#6-电机参数)
- [典型调参场景](#典型调参场景)
- [常见问题排查](#常见问题排查)
- [参数速查表](#参数速查表)

---

## 概述

### 功率控制器的作用

底盘功率控制器负责：
1. **防止超功率**：确保底盘功率不超过裁判系统限制（通常80W），避免扣血
2. **自适应参数辨识**：使用RLS算法自动学习电机功率模型参数
3. **能量管理**：根据电容/裁判系统能量缓冲，动态调整功率分配
4. **智能功率分配**：在功率受限时，合理分配给4个轮子

### 功率模型公式

```
总功率 = Σ[转矩i × 转速i] + k1 × Σ|转速i| + k2 × Σ(转矩i²) + k3
         └─有效功率─┘   └──摩擦损耗──┘   └───电阻损耗───┘   └静态损耗┘
```

**参数说明**：
- **k1**：转速损耗系数（摩擦损耗），单位：W/(rad/s)
- **k2**：力矩平方损耗系数（电阻损耗I²R），单位：W/(N·m)²
- **k3**：静态功率损耗（电路损耗），单位：W

---

## 快速开始

### 默认配置（开箱即用）

```c
// 在 chassis.c 或主初始化文件中
PowerControllerConfig_t power_config = {
    .k1_init = 0.22f,           // k1初始值
    .k2_init = 1.2f,            // k2初始值
    .k3 = 4.823f,               // 静态损耗
    .rls_lambda = 0.995f,       // RLS遗忘因子
    .torque_constant = 0.3f,    // M3508转矩常数
    .current_scale = 20.0f / 16384.0f,  // CAN电流转换系数
};

PowerControllerInit(&power_config);
```

### 调用流程

```c
// 1. 初始化（启动时调用一次）
PowerControllerInit(&power_config);

// 2. 周期任务（1-5ms周期，独立任务）
void PowerControllerTask(void) {
    // 内部自动完成：
    // - 能量环PD控制
    // - RLS参数更新
}

// 3. 实时功率限制（在底盘控制任务中调用）
PowerMotorObj_t motor_objs[4];  // 准备电机数据
float output[4];                // 接收限制后的输出
PowerGetLimitedOutput(motor_objs, output);  // 获取功率受限后的输出

// 4. 数据更新（根据数据来源调用）
PowerUpdateRefereeData(power_limit, power_buffer, chassis_power);
PowerUpdateCapData(cap_voltage, cap_online);
PowerUpdateMotorFeedback(motor_speeds, motor_torques);
```

---

## 参数分类详解

### 1. 使能开关

#### `POWER_CONTROLLER_ENABLE`
- **位置**：`power_controller.h:20`
- **默认值**：`1`
- **作用**：功率控制总开关
- **取值**：
  - `1` - 使能功率控制（正常比赛模式）
  - `0` - 禁用功率控制（测试模式，**危险**）
- **调整建议**：
  - ✅ 比赛时必须设为 `1`
  - ⚠️ 仅在安全测试环境下可以设为 `0`（会超功率）

#### `RLS_ENABLE`
- **位置**：`power_controller.h:21`
- **默认值**：`1`
- **作用**：RLS参数辨识使能开关
- **取值**：
  - `1` - 使能自适应参数辨识
  - `0` - 禁用RLS，使用固定的k1、k2初始值
- **调整建议**：
  - ✅ 推荐始终开启（自适应能力）
  - ⚠️ 如果RLS导致参数震荡，可临时关闭调试

---

### 2. 能量环PD控制器参数

#### `POWER_PD_KP`（比例增益）
- **位置**：`power_controller.h:24`
- **默认值**：`25.0f`（已优化，原值50.0f）
- **作用**：控制能量误差对功率限制的响应强度
- **物理意义**：能量误差每变化1个单位（sqrt变换后），功率限制变化25W
- **取值范围**：`10.0 ~ 50.0`
- **调整指南**：

  | 现象 | 原因 | 调整方向 |
  |------|------|---------|
  | 功率超调严重（瞬间超100W） | Kp太大 | **降低** Kp（15-20） |
  | 能量缓冲耗尽，响应太慢 | Kp太小 | **增大** Kp（30-40） |
  | 功率震荡（±20W波动） | Kp太大或Kd太小 | **降低** Kp 或 **增大** Kd |

**典型值参考**：
- 保守（稳定优先）：`Kp = 20.0`
- 推荐（平衡）：`Kp = 25.0` ✅
- 激进（响应优先）：`Kp = 35.0`

#### `POWER_PD_KD`（微分增益）
- **位置**：`power_controller.h:25`
- **默认值**：`0.8f`（已优化，原值0.2f）
- **作用**：提供阻尼，抑制震荡
- **物理意义**：能量误差变化率每变化1个单位/s，功率限制变化0.8W
- **取值范围**：`0.2 ~ 2.0`
- **调整指南**：

  | 现象 | 原因 | 调整方向 |
  |------|------|---------|
  | 功率持续震荡 | Kd太小 | **增大** Kd（1.0-1.5） |
  | 响应迟钝，不灵敏 | Kd太大 | **降低** Kd（0.5-0.8） |
  | 噪声放大，抖动 | Kd太大 | **降低** Kd 或 **增加滤波** |

**典型值参考**：
- 低阻尼（快速响应）：`Kd = 0.5`
- 推荐（平衡）：`Kd = 0.8` ✅
- 高阻尼（抑制震荡）：`Kd = 1.2`

**调参技巧**：
1. **阶跃响应法**：
   ```
   静止 → 全速前进 → 观察功率曲线
   - 超调量 > 20% → 降低Kp或增大Kd
   - 调节时间 > 2s → 增大Kp
   - 持续震荡 → 增大Kd
   ```

2. **Kp和Kd的关系**：
   ```
   Kp/Kd 比值 = 20~50 为宜
   当前：25.0/0.8 = 31.25 ✅
   ```

---

### 3. 功率分配参数

#### `ERROR_POWER_DISTRIBUTION_THRESHOLD`
- **位置**：`power_controller.h:28`
- **默认值**：`20.0f`
- **单位**：rad/s（总速度误差）
- **作用**：速度误差分配策略的激活阈值**上限**
- **含义**：
  - 当 4个轮子的总速度误差 > 20 rad/s 时，**完全按速度误差分配功率**
  - 误差大的轮子分配更多功率，加速追上目标速度

**示例**：
```
场景：小陀螺急转，左侧轮子速度误差很大
- 轮子1误差：8 rad/s
- 轮子2误差：7 rad/s
- 轮子3误差：3 rad/s
- 轮子4误差：2 rad/s
- 总误差：20 rad/s → 达到阈值上限

功率分配：
- 轮子1：8/20 × 总功率 = 40%
- 轮子2：7/20 × 总功率 = 35%
- 轮子3：3/20 × 总功率 = 15%
- 轮子4：2/20 × 总功率 = 10%
```

#### `PROP_POWER_DISTRIBUTION_THRESHOLD`
- **位置**：`power_controller.h:29`
- **默认值**：`15.0f`
- **单位**：rad/s（总速度误差）
- **作用**：速度误差分配策略的激活阈值**下限**
- **含义**：
  - 当 总速度误差 < 15 rad/s 时，**完全按功率需求比例分配**
  - 需要功率多的轮子分配更多功率

**混合策略**：
```
总误差范围         分配策略
─────────────────────────────────
> 20 rad/s         100% 按误差分配
15~20 rad/s        线性插值混合
< 15 rad/s         100% 按功率比例分配
```

**公式**：
```c
if (总误差 > 20) {
    error_confidence = 1.0;  // 完全按误差
} else if (总误差 > 15) {
    error_confidence = (总误差 - 15) / (20 - 15);  // 线性过渡
} else {
    error_confidence = 0.0;  // 完全按功率比例
}

weight = error_confidence × 误差权重 + (1 - error_confidence) × 功率权重
```

**调整建议**：
- **提高灵敏度**：降低两个阈值（例如12和17）
- **提高稳定性**：增大两个阈值（例如18和25）
- **保持差值**：两者相差5 rad/s左右为宜

---

### 4. 能量缓冲阈值

#### 裁判系统相关

##### `REFEREE_FULL_BUFF`
- **位置**：`power_controller.h:32`
- **默认值**：`60.0f`
- **单位**：焦耳（J）
- **作用**：裁判系统满能量缓冲目标值
- **说明**：裁判系统能量缓冲范围 0-60J，当缓冲充满时为60J
- **调整建议**：⚠️ **不建议修改**，这是裁判系统规则定义的值

##### `REFEREE_BASE_BUFF`
- **位置**：`power_controller.h:33`
- **默认值**：`50.0f`
- **单位**：焦耳（J）
- **作用**：裁判系统基准能量缓冲值
- **说明**：当缓冲低于50J时，PD控制器会限制功率，保护缓冲不耗尽
- **调整建议**：
  - **保守**：55J（更早限制功率，保护能量）
  - **激进**：45J（允许更多冲刺，但风险高）

#### 超级电容相关

##### `CAP_FULL_BUFF`
- **位置**：`power_controller.h:34`
- **默认值**：`230.0f`
- **单位**：电压值（0-255范围）
- **作用**：超级电容满电压目标值
- **说明**：超级电容反馈电压范围0-255，230表示充满状态
- **调整建议**：
  - 根据实际电容充满电压调整（通常220-240）
  - 与电容通信协议定义一致

##### `CAP_BASE_BUFF`
- **位置**：`power_controller.h:35`
- **默认值**：`30.0f`
- **单位**：电压值（0-255范围）
- **作用**：超级电容基准电压值
- **说明**：当电容电压低于30时，PD控制器会限制功率
- **调整建议**：
  - **保守**：50（早保护，电容寿命长）
  - **激进**：20（允许深度放电，但损伤电容）

##### `MAX_CAP_POWER_OUT`
- **位置**：`power_controller.h:36`
- **默认值**：`300.0f`
- **单位**：瓦特（W）
- **作用**：超级电容最大输出功率
- **说明**：当电容在线时，允许功率上限 = 裁判限制 + 300W
- **调整建议**：
  - 根据电容实际最大输出功率设置
  - 典型值：200W-400W

##### `CAP_OFFLINE_THRESHOLD`
- **位置**：`power_controller.h:37`
- **默认值**：`43.0f`
- **单位**：电压值（0-255范围）
- **作用**：电容离线判断阈值
- **说明**：当电容电压低于此值时，判定为离线
- **调整建议**：根据电容通信协议调整

---

### 5. RLS初始化参数

#### `k1_init`（k1初始值）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`0.22f`
- **单位**：W/(rad/s)
- **作用**：转速损耗系数初始值（摩擦损耗）
- **物理意义**：每 rad/s 转速产生 0.22W 摩擦损耗
- **取值范围**：`0.1 ~ 0.5`
- **典型值**：
  - 新电机/润滑好：`0.15`
  - 正常磨损：`0.22` ✅
  - 老化/摩擦大：`0.35`

**RLS会自动调整此值，初始值影响收敛速度**

#### `k2_init`（k2初始值）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`1.2f`
- **单位**：W/(N·m)²
- **作用**：力矩平方损耗系数初始值（电阻损耗I²R）
- **物理意义**：每 (N·m)² 转矩产生 1.2W 电阻损耗
- **取值范围**：`0.5 ~ 2.0`（⚠️ 注意：controller.c中限幅已改为1.5）
- **典型值**：
  - 理论计算值：`0.8`
  - 推荐实测值：`1.2` ✅
  - 老化电机：`1.5`

**重要提示**：
- ⚠️ 之前限幅0.5导致RLS无法收敛，已修复为1.5
- RLS会自动调整此值，通常收敛到0.8-1.3

#### `k3`（静态功率损耗）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`4.823f`
- **单位**：W
- **作用**：静态功率损耗（电路损耗、控制器损耗等）
- **物理意义**：底盘即使静止，也会消耗约4.8W功率
- **取值范围**：`2.0 ~ 8.0`
- **调整建议**：
  - 通过实测确定：静止时测量裁判系统功率
  - ⚠️ **不建议频繁调整**，这是固定损耗

#### `rls_lambda`（RLS遗忘因子）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`0.995f`
- **取值范围**：`0.90 ~ 0.999`
- **作用**：控制RLS算法的收敛速度和适应能力
- **物理意义**：
  - λ = 1.0：完全记忆，不适应新数据（不推荐）
  - λ = 0.995：推荐值，平衡收敛速度和稳定性
  - λ = 0.98：快速适应，但可能震荡
  - λ = 0.90：非常快速，但极易震荡（不推荐）

**调整指南**：

| 现象 | 原因 | 调整方向 |
|------|------|---------|
| RLS收敛太慢（>5分钟） | λ太大 | **降低** λ（0.99） |
| RLS参数震荡不稳定 | λ太小 | **增大** λ（0.997） |
| 电机更换后适应慢 | λ太大 | **临时降低** λ（0.98） |

**典型值参考**：
- 慢收敛（稳定）：`λ = 0.998`
- 推荐（平衡）：`λ = 0.995` ✅
- 快收敛（激进）：`λ = 0.990`

#### `delta`（RLS协方差矩阵初始值）
- **位置**：`power_controller.c:220`（代码硬编码）
- **默认值**：`1e-5f`（0.00001）
- **作用**：协方差矩阵P的初始对角线值
- **取值范围**：`1e-6 ~ 1e-3`
- **物理意义**：
  - delta小：对初始参数有信心，收敛慢但稳定
  - delta大：对初始参数不确定，收敛快但首次更新剧变

**调整建议**：
- 推荐值：`1e-5` ✅（默认）
- 如果首次更新参数跳变太大：降低到 `1e-6`
- 如果收敛太慢：增大到 `1e-4`
- ⚠️ **不建议超过1e-3**，会导致首次更新参数爆炸

---

### 6. 电机参数

#### `torque_constant`（电机转矩常数）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`0.3f`
- **单位**：N·m/A
- **作用**：电流到转矩的转换系数
- **物理意义**：每安培电流产生0.3 N·m转矩
- **M3508规格值**：`0.3 N·m/A` ✅
- **其他电机**：
  - M2006：`0.18 N·m/A`
  - GM6020：需查阅数据手册

**调整建议**：⚠️ **严格按电机数据手册设置，不要随意修改**

#### `current_scale`（电流转换系数）
- **位置**：`PowerControllerConfig_t` 结构体
- **默认值**：`20.0f / 16384.0f ≈ 0.00122`
- **作用**：CAN指令值到实际电流的转换
- **公式**：`电流(A) = CAN指令值 × current_scale`
- **M3508/M2006规格**：
  - CAN指令值范围：-16384 ~ +16384
  - 实际电流范围：-20A ~ +20A
  - 转换系数：20.0 / 16384.0

**调整建议**：⚠️ **根据电机CAN协议设置，不要随意修改**

---

## 典型调参场景

### 场景1：功率超调严重

**症状**：
- 功率瞬间从60W跳到120W
- 能量缓冲快速耗尽
- 裁判系统报警

**排查步骤**：
1. **检查PD参数**：
   ```c
   POWER_PD_KP = 25.0f  // 如果仍超调，降到20.0
   POWER_PD_KD = 0.8f   // 如果仍超调，增到1.0
   ```

2. **检查RLS收敛性**：
   - Ozone监控 `controller_status.k1` 和 `k2`
   - 如果k2顶在1.5不收敛 → 可能需要进一步放宽限幅

3. **检查数据源**：
   - 确认 `referee_data.chassis_power` 数据正常
   - 确认电容上线/下线切换时无跳变

### 场景2：RLS参数不收敛

**症状**：
- k1、k2持续震荡
- 功率预测误差很大（>20%）

**排查步骤**：
1. **检查限幅**：
   ```c
   // controller.c:281-282
   if (rls->params_vector[1] > 1.5f)  // 确认已修复
       rls->params_vector[1] = 1.5f;
   ```

2. **检查遗忘因子**：
   ```c
   .rls_lambda = 0.995f  // 如果震荡，增大到0.997
   ```

3. **检查输入数据质量**：
   - 功率阈值：只在 chassis_power > 5W 时更新
   - 确认电机反馈数据正常

### 场景3：能量缓冲频繁耗尽

**症状**：
- power_buffer经常降到0
- 机器人突然减速

**解决方案**：
1. **降低基准能量**（更早限制功率）：
   ```c
   #define REFEREE_BASE_BUFF 55.0f  // 从50改为55
   ```

2. **增大PD控制器Kp**（更快响应）：
   ```c
   #define POWER_PD_KP 30.0f  // 从25改为30
   ```

3. **检查功率分配**：
   - 是否某个轮子分配过多功率？
   - 调整分配阈值

### 场景4：电容切换时功率跳变

**症状**：
- 电容上线/下线时，chassis_power突变
- 从-118W跳到505W

**解决方案**：
1. **数据源确认**：
   - ⚠️ **重要更正**：当前配置（无裁判系统）下，RLS使用的是**超级电容反馈的 chassis_power 数据**
   - 数据流：cap_rx_data.chassis_power → PowerUpdateRefereeData() → referee_data.chassis_power → RLS
   - 虽然内部变量名为 referee_data，但实际数据来自电容

2. **添加平滑滤波**（可选）：
   ```c
   // chassis.c中添加一阶滤波
   static float last_power = 0.0f;
   float current_power = cap_online ? cap_power : referee_power;
   chassis_power_filtered = 0.9f * current_power + 0.1f * last_power;
   ```

---

## 常见问题排查

### Q1: 如何确认RLS是否在正常工作？

**检查方法**：
1. Ozone监控变量：
   ```c
   controller_status.rls_enabled  // 应为1
   power_rls.update_cnt           // 应持续增加
   controller_status.k1           // 观察是否收敛
   controller_status.k2           // 观察是否收敛
   ```

2. 预期行为：
   - 启动后15-30分钟，k1、k2逐渐收敛到稳定值
   - `update_cnt` 每秒增加若干次（取决于功率是否>5W）

### Q2: 如何手动禁用RLS？

**方法1**：修改宏定义
```c
// power_controller.h:21
#define RLS_ENABLE 0  // 改为0
```

**方法2**：运行时禁用
```c
PowerSetRLSEnable(0);  // 调用函数禁用
```

### Q3: 功率控制器任务应该多快运行？

**推荐频率**：1-5ms（200Hz-1kHz）

```c
// FreeRTOS任务示例
void PowerControllerTaskEntry(void const *argument) {
    for(;;) {
        PowerControllerTask();  // 内部完成能量环和RLS
        osDelay(1);  // 1ms周期 = 1kHz ✅ 推荐
    }
}
```

### Q4: 如何查看当前功率控制器状态？

**方法**：调用状态查询接口
```c
const PowerControllerStatus_t *status = PowerGetStatus();

// 查看状态
float k1 = status->k1;                 // 当前k1
float k2 = status->k2;                 // 当前k2
float max_power = status->max_power_limit;  // 当前功率上限
uint8_t cap_online = status->cap_online;    // 电容在线状态
uint8_t rls_enabled = status->rls_enabled;  // RLS使能状态
```

### Q5: 参数修改后需要重新烧录吗？

**答案**：是的，所有宏定义参数（.h文件）和初始化参数修改后，都需要重新编译烧录。

**建议流程**：
1. 修改参数
2. 重新编译：`make clean && make -j8`
3. 烧录：`make download_dap` 或 `make download_jlink`
4. 测试验证

---

## 参数速查表

### 宏定义参数（power_controller.h）

| 参数名 | 默认值 | 单位 | 作用 | 调整建议 |
|--------|--------|------|------|---------|
| `POWER_CONTROLLER_ENABLE` | `1` | - | 功率控制总开关 | ⚠️ 比赛时必须为1 |
| `RLS_ENABLE` | `1` | - | RLS使能 | ✅ 推荐开启 |
| `POWER_PD_KP` | `25.0f` | - | PD比例增益 | 10.0~50.0 |
| `POWER_PD_KD` | `0.8f` | - | PD微分增益 | 0.2~2.0 |
| `ERROR_POWER_DISTRIBUTION_THRESHOLD` | `20.0f` | rad/s | 误差分配阈值上限 | 15~25 |
| `PROP_POWER_DISTRIBUTION_THRESHOLD` | `15.0f` | rad/s | 误差分配阈值下限 | 10~20 |
| `REFEREE_FULL_BUFF` | `60.0f` | J | 裁判满能量 | ⚠️ 不建议改 |
| `REFEREE_BASE_BUFF` | `50.0f` | J | 裁判基准能量 | 45~55 |
| `CAP_FULL_BUFF` | `230.0f` | 0-255 | 电容满电压 | 220~240 |
| `CAP_BASE_BUFF` | `30.0f` | 0-255 | 电容基准电压 | 20~50 |
| `MAX_CAP_POWER_OUT` | `300.0f` | W | 电容最大输出 | 200~400 |

### 初始化参数（PowerControllerConfig_t）

| 参数名 | 默认值 | 单位 | 作用 | 调整建议 |
|--------|--------|------|------|---------|
| `k1_init` | `0.22f` | W/(rad/s) | k1初始值 | 0.1~0.5 |
| `k2_init` | `1.2f` | W/(N·m)² | k2初始值 | 0.5~2.0 |
| `k3` | `4.823f` | W | 静态损耗 | ⚠️ 实测确定 |
| `rls_lambda` | `0.995f` | - | RLS遗忘因子 | 0.99~0.998 |
| `torque_constant` | `0.3f` | N·m/A | M3508转矩常数 | ⚠️ 按数据手册 |
| `current_scale` | `20.0/16384` | - | 电流转换系数 | ⚠️ 按CAN协议 |

### 内部参数（power_controller.c）

| 参数名 | 默认值 | 位置 | 作用 | 调整建议 |
|--------|--------|------|------|---------|
| `delta` | `1e-5f` | line 220 | RLS协方差初始值 | 1e-6~1e-3 |

---

## 附录：完整配置示例

### 标准配置（推荐）

```c
// ============= 宏定义参数（power_controller.h）=============
#define POWER_CONTROLLER_ENABLE 1
#define RLS_ENABLE 1

#define POWER_PD_KP 25.0f  // 已优化
#define POWER_PD_KD 0.8f   // 已优化

#define ERROR_POWER_DISTRIBUTION_THRESHOLD 20.0f
#define PROP_POWER_DISTRIBUTION_THRESHOLD 15.0f

#define REFEREE_FULL_BUFF 60.0f
#define REFEREE_BASE_BUFF 50.0f
#define CAP_FULL_BUFF 230.0f
#define CAP_BASE_BUFF 30.0f
#define MAX_CAP_POWER_OUT 300.0f
#define CAP_OFFLINE_THRESHOLD 43.0f

// ============= 初始化参数（chassis.c）=============
PowerControllerConfig_t power_config = {
    .k1_init = 0.22f,
    .k2_init = 1.2f,
    .k3 = 4.823f,
    .rls_lambda = 0.995f,
    .torque_constant = 0.3f,
    .current_scale = 20.0f / 16384.0f,
};
```

### 保守配置（稳定优先）

```c
// 更大阻尼，更早保护能量
#define POWER_PD_KP 20.0f   // 降低响应
#define POWER_PD_KD 1.0f    // 增大阻尼

#define REFEREE_BASE_BUFF 55.0f  // 更早保护
#define CAP_BASE_BUFF 50.0f      // 更早保护

PowerControllerConfig_t power_config = {
    .rls_lambda = 0.997f,  // 更慢收敛，更稳定
    // ... 其他同标准配置
};
```

### 激进配置（性能优先）

```c
// 更快响应，允许更多冲刺
#define POWER_PD_KP 35.0f   // 增大响应
#define POWER_PD_KD 0.5f    // 降低阻尼

#define REFEREE_BASE_BUFF 45.0f  // 允许更低缓冲
#define CAP_BASE_BUFF 20.0f      // 允许深度放电

PowerControllerConfig_t power_config = {
    .rls_lambda = 0.990f,  // 更快收敛
    // ... 其他同标准配置
};
```

---

## 版本历史

| 版本 | 日期 | 修改内容 |
|------|------|---------|
| v2.0 | 2025-01-18 | 修复RLS k2限幅问题（0.5→1.5），优化PD参数（Kp:50→25, Kd:0.2→0.8） |
| v1.0 | 2024-10-30 | 初始版本 |

---

## 参考资料

1. **代码文件**：
   - `Chassis/modules/power_controller/power_controller.h`
   - `Chassis/modules/power_controller/power_controller.c`
   - `Chassis/modules/algorithm/controller.c` （RLS算法实现）

2. **相关文档**：
   - `底盘LQR力控使用指南.md`
   - `底盘系统辨识快速参考.md`

3. **调试工具**：
   - Ozone实时调试器
   - SEGGER RTT日志系统

---

**文档结束**

如有疑问，请参考代码注释或联系原作者 Wanqiq。
